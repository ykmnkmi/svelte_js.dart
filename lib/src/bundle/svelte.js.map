{"version":3,"file":"svelte.js","sources":["../../../node_modules/svelte/src/internal/client/utils.js","../../../node_modules/svelte/src/internal/client/constants.js","../../../node_modules/svelte/src/internal/client/reactivity/equality.js","../../../node_modules/svelte/src/internal/client/reactivity/sources.js","../../../node_modules/svelte/src/internal/client/reactivity/effects.js","../../../node_modules/svelte/src/internal/client/reactivity/deriveds.js","../../../node_modules/svelte/src/internal/common.js","../../../node_modules/svelte/src/internal/client/dom/task.js","../../../node_modules/svelte/src/internal/client/runtime.js","../../../node_modules/svelte/src/internal/client/dom/operations.js","../../../node_modules/svelte/src/internal/client/dom/reconciler.js","../../../node_modules/svelte/src/constants.js","../../../node_modules/svelte/src/internal/client/dom/blocks/each.js","../../../node_modules/svelte/src/internal/client/dom/elements/transitions.js","../../../node_modules/svelte/src/internal/client/dom/blocks/await.js","../../../node_modules/svelte/src/internal/client/dom/blocks/if.js","../../../node_modules/svelte/src/internal/client/dom/blocks/html.js","../../../node_modules/svelte/src/internal/client/render.js","../../../node_modules/svelte/src/internal/client/dom/elements/events.js","../../../node_modules/svelte/src/internal/client/dom/elements/attributes.js","../../../node_modules/svelte/src/internal/client/dom/legacy/lifecycle.js","../../../node_modules/svelte/src/internal/client/dom/legacy/misc.js","../../../node_modules/svelte/src/internal/client/dom/template.js","../../../node_modules/svelte/src/internal/client/reactivity/props.js","../../../node_modules/svelte/src/main/main-client.js","../../../src/svelte.js"],"sourcesContent":["// Store the references to globals in case someone tries to monkey patch these, causing the below\n// to de-opt (this occurs often when using popular extensions).\nexport var is_array = Array.isArray;\nexport var array_from = Array.from;\nexport var object_keys = Object.keys;\nexport var object_assign = Object.assign;\nexport var is_frozen = Object.isFrozen;\nexport var object_freeze = Object.freeze;\nexport var define_property = Object.defineProperty;\nexport var get_descriptor = Object.getOwnPropertyDescriptor;\nexport var get_descriptors = Object.getOwnPropertyDescriptors;\nexport var object_prototype = Object.prototype;\nexport var array_prototype = Array.prototype;\nexport var get_prototype_of = Object.getPrototypeOf;\n\n/** @type {Map<any, any>} */\nvar map_prototype = Map.prototype;\nvar map_set_method = map_prototype.set;\nvar map_get_method = map_prototype.get;\nvar map_delete_method = map_prototype.delete;\n\n/**\n * @template K\n * @template V\n * @param {Map<K, V>} map\n * @param {K} key\n * @param {V} value\n */\nexport function map_set(map, key, value) {\n\tmap_set_method.call(map, key, value);\n}\n\n/**\n * @template K\n * @template V\n * @param {Map<K, V>} map\n * @param {K} key\n */\nexport function map_delete(map, key) {\n\tmap_delete_method.call(map, key);\n}\n\n/**\n * @template K\n * @template V\n * @param {Map<K, V>} map\n * @param {K} key\n * @return {V}\n */\nexport function map_get(map, key) {\n\treturn map_get_method.call(map, key);\n}\n\n/**\n * @param {any} thing\n * @returns {thing is Function}\n */\nexport function is_function(thing) {\n\treturn typeof thing === 'function';\n}\n","export const DERIVED = 1 << 1;\nexport const EFFECT = 1 << 2;\nexport const PRE_EFFECT = 1 << 3;\nexport const RENDER_EFFECT = 1 << 4;\nexport const MANAGED = 1 << 6;\nexport const UNOWNED = 1 << 7;\nexport const CLEAN = 1 << 8;\nexport const DIRTY = 1 << 9;\nexport const MAYBE_DIRTY = 1 << 10;\nexport const INERT = 1 << 11;\nexport const DESTROYED = 1 << 12;\n\nexport const ROOT_BLOCK = 0;\nexport const IF_BLOCK = 1;\nexport const EACH_BLOCK = 2;\nexport const EACH_ITEM_BLOCK = 3;\nexport const AWAIT_BLOCK = 4;\nexport const KEY_BLOCK = 5;\nexport const HEAD_BLOCK = 6;\nexport const DYNAMIC_COMPONENT_BLOCK = 7;\nexport const DYNAMIC_ELEMENT_BLOCK = 8;\nexport const SNIPPET_BLOCK = 9;\n\nexport const UNINITIALIZED = Symbol();\nexport const STATE_SYMBOL = Symbol('$state');\n","/** @type {import('#client').Equals} */\nexport function equals(value) {\n\treturn value === this.v;\n}\n\n/**\n * @param {unknown} a\n * @param {unknown} b\n * @returns {boolean}\n */\nexport function safe_not_equal(a, b) {\n\t// eslint-disable-next-line eqeqeq\n\treturn a != a\n\t\t? // eslint-disable-next-line eqeqeq\n\t\t\tb == b\n\t\t: a !== b || (a !== null && typeof a === 'object') || typeof a === 'function';\n}\n\n/** @type {import('#client').Equals} */\nexport function safe_equals(value) {\n\treturn !safe_not_equal(value, this.v);\n}\n","import { DEV } from 'esm-env';\nimport {\n\tcurrent_component_context,\n\tcurrent_reaction,\n\tcurrent_dependencies,\n\tcurrent_effect,\n\tcurrent_untracked_writes,\n\tcurrent_untracking,\n\tflushSync,\n\tget,\n\tis_batching_effect,\n\tis_runes,\n\tmark_reactions,\n\tschedule_effect,\n\tset_current_untracked_writes,\n\tset_last_inspected_signal,\n\tset_signal_status,\n\tuntrack\n} from '../runtime.js';\nimport { equals, safe_equals } from './equality.js';\nimport { CLEAN, DERIVED, DIRTY, MANAGED, UNINITIALIZED } from '../constants.js';\n\n/**\n * @template V\n * @param {V} value\n * @returns {import('#client').Source<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function source(value) {\n\t/** @type {import('#client').Source<V>} */\n\tconst source = {\n\t\tf: 0, // TODO ideally we could skip this altogether, but it causes type errors\n\t\treactions: null,\n\t\tequals: equals,\n\t\tv: value,\n\t\tversion: 0\n\t};\n\n\tif (DEV) {\n\t\t/** @type {import('#client').ValueDebug<V>} */ (source).inspect = new Set();\n\t}\n\n\treturn source;\n}\n\n/**\n * @template V\n * @param {V} initial_value\n * @returns {import('#client').Source<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function mutable_source(initial_value) {\n\tconst s = source(initial_value);\n\ts.equals = safe_equals;\n\n\t// bind the signal to the component context, in case we need to\n\t// track updates to trigger beforeUpdate/afterUpdate callbacks\n\tif (current_component_context) {\n\t\t(current_component_context.d ??= []).push(s);\n\t}\n\n\treturn s;\n}\n\n/**\n * @template V\n * @param {import('#client').Source<V>} signal\n * @param {V} value\n * @returns {void}\n */\nexport function set_sync(signal, value) {\n\tflushSync(() => set(signal, value));\n}\n\n/**\n * @template V\n * @param {import('#client').Value<V>} source\n * @param {V} value\n */\nexport function mutate(source, value) {\n\tset(\n\t\tsource,\n\t\tuntrack(() => get(source))\n\t);\n\treturn value;\n}\n\n/**\n * @template V\n * @param {import('#client').Source<V>} signal\n * @param {V} value\n * @returns {V}\n */\nexport function set(signal, value) {\n\tvar initialized = signal.v !== UNINITIALIZED;\n\n\tif (\n\t\t!current_untracking &&\n\t\tinitialized &&\n\t\tcurrent_reaction !== null &&\n\t\tis_runes() &&\n\t\t(current_reaction.f & DERIVED) !== 0\n\t) {\n\t\tthrow new Error(\n\t\t\t'ERR_SVELTE_UNSAFE_MUTATION' +\n\t\t\t\t(DEV\n\t\t\t\t\t? \": Unsafe mutations during Svelte's render or derived phase are not permitted in runes mode. \" +\n\t\t\t\t\t\t'This can lead to unexpected errors and possibly cause infinite loops.\\n\\nIf this mutation is not meant ' +\n\t\t\t\t\t\t'to be reactive do not use the \"$state\" rune for that declaration.'\n\t\t\t\t\t: '')\n\t\t);\n\t}\n\n\tif (!signal.equals(value)) {\n\t\tsignal.v = value;\n\n\t\t// Increment write version so that unowned signals can properly track dirtiness\n\t\tsignal.version++;\n\n\t\t// If the current signal is running for the first time, it won't have any\n\t\t// reactions as we only allocate and assign the reactions after the signal\n\t\t// has fully executed. So in the case of ensuring it registers the reaction\n\t\t// properly for itself, we need to ensure the current effect actually gets\n\t\t// scheduled. i.e:\n\t\t//\n\t\t// $effect(() => x++)\n\t\t//\n\t\t// We additionally want to skip this logic when initialising store sources\n\t\tif (\n\t\t\tis_runes() &&\n\t\t\tinitialized &&\n\t\t\tcurrent_effect !== null &&\n\t\t\t(current_effect.f & CLEAN) !== 0 &&\n\t\t\t(current_effect.f & MANAGED) === 0\n\t\t) {\n\t\t\tif (current_dependencies !== null && current_dependencies.includes(signal)) {\n\t\t\t\tset_signal_status(current_effect, DIRTY);\n\t\t\t\tschedule_effect(current_effect, false);\n\t\t\t} else {\n\t\t\t\tif (current_untracked_writes === null) {\n\t\t\t\t\tset_current_untracked_writes([signal]);\n\t\t\t\t} else {\n\t\t\t\t\tcurrent_untracked_writes.push(signal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmark_reactions(signal, DIRTY, true);\n\n\t\tif (DEV) {\n\t\t\tif (is_batching_effect) {\n\t\t\t\tset_last_inspected_signal(/** @type {import('#client').ValueDebug} */ (signal));\n\t\t\t} else {\n\t\t\t\tfor (const fn of /** @type {import('#client').ValueDebug} */ (signal).inspect) fn();\n\t\t\t}\n\t\t}\n\t}\n\n\treturn value;\n}\n","import { DEV } from 'esm-env';\nimport {\n\tcurrent_block,\n\tcurrent_component_context,\n\tcurrent_effect,\n\tcurrent_reaction,\n\tdestroy_children,\n\tget,\n\tremove_reactions,\n\tschedule_effect,\n\tset_signal_status,\n\tuntrack\n} from '../runtime.js';\nimport { DIRTY, MANAGED, RENDER_EFFECT, EFFECT, PRE_EFFECT, DESTROYED } from '../constants.js';\nimport { set } from './sources.js';\n\n/**\n * @param {import('./types.js').EffectType} type\n * @param {(() => void | (() => void)) | ((b: import('#client').Block) => void | (() => void))} fn\n * @param {boolean} sync\n * @param {null | import('#client').Block} block\n * @param {boolean} init\n * @returns {import('#client').Effect}\n */\nfunction create_effect(type, fn, sync, block = current_block, init = true) {\n\t/** @type {import('#client').Effect} */\n\tconst signal = {\n\t\tblock,\n\t\tdeps: null,\n\t\tf: type | DIRTY,\n\t\tl: 0,\n\t\tfn,\n\t\teffects: null,\n\t\tderiveds: null,\n\t\tteardown: null,\n\t\tctx: current_component_context,\n\t\tondestroy: null\n\t};\n\n\tif (current_effect !== null) {\n\t\tsignal.l = current_effect.l + 1;\n\t}\n\n\tif (current_reaction !== null) {\n\t\tif (current_reaction.effects === null) {\n\t\t\tcurrent_reaction.effects = [signal];\n\t\t} else {\n\t\t\tcurrent_reaction.effects.push(signal);\n\t\t}\n\t}\n\n\tif (init) {\n\t\tschedule_effect(signal, sync);\n\t}\n\n\treturn signal;\n}\n\n/**\n * Internal representation of `$effect.active()`\n * @returns {boolean}\n */\nexport function effect_active() {\n\treturn current_effect ? (current_effect.f & MANAGED) === 0 : false;\n}\n\n/**\n * Internal representation of `$effect(...)`\n * @param {() => void | (() => void)} fn\n * @returns {import('#client').Effect}\n */\nexport function user_effect(fn) {\n\tif (current_effect === null) {\n\t\tthrow new Error(\n\t\t\t'ERR_SVELTE_ORPHAN_EFFECT' +\n\t\t\t\t(DEV ? ': The Svelte $effect rune can only be used during component initialisation.' : '')\n\t\t);\n\t}\n\n\t// Non-nested `$effect(...)` in a component should be deferred\n\t// until the component is mounted\n\tconst defer =\n\t\tcurrent_effect.f & RENDER_EFFECT &&\n\t\t// TODO do we actually need this? removing them changes nothing\n\t\tcurrent_component_context !== null &&\n\t\t!current_component_context.m;\n\n\tconst effect = create_effect(EFFECT, fn, false, current_block, !defer);\n\n\tif (defer) {\n\t\tconst context = /** @type {import('#client').ComponentContext} */ (current_component_context);\n\t\t(context.e ??= []).push(effect);\n\t}\n\n\treturn effect;\n}\n\n/**\n * Internal representation of `$effect.root(...)`\n * @param {() => void | (() => void)} fn\n * @returns {() => void}\n */\nexport function user_root_effect(fn) {\n\tconst effect = render_effect(fn, current_block, true);\n\treturn () => {\n\t\tdestroy_effect(effect);\n\t};\n}\n\n/**\n * @param {() => void | (() => void)} fn\n * @returns {import('#client').Effect}\n */\nexport function effect(fn) {\n\treturn create_effect(EFFECT, fn, false);\n}\n\n/**\n * @param {() => void | (() => void)} fn\n * @returns {import('#client').Effect}\n */\nexport function managed_effect(fn) {\n\treturn create_effect(EFFECT | MANAGED, fn, false);\n}\n\n/**\n * @param {() => void | (() => void)} fn\n * @returns {import('#client').Effect}\n */\nexport function managed_pre_effect(fn) {\n\treturn create_effect(PRE_EFFECT | MANAGED, fn, false);\n}\n\n/**\n * Internal representation of `$effect.pre(...)`\n * @param {() => void | (() => void)} fn\n * @returns {import('#client').Effect}\n */\nexport function pre_effect(fn) {\n\tif (current_effect === null) {\n\t\tthrow new Error(\n\t\t\t'ERR_SVELTE_ORPHAN_EFFECT' +\n\t\t\t\t(DEV\n\t\t\t\t\t? ': The Svelte $effect.pre rune can only be used during component initialisation.'\n\t\t\t\t\t: '')\n\t\t);\n\t}\n\tconst sync = current_effect !== null && (current_effect.f & RENDER_EFFECT) !== 0;\n\n\treturn create_effect(PRE_EFFECT, fn, sync);\n}\n\n/**\n * Internal representation of `$: ..`\n * @param {() => any} deps\n * @param {() => void | (() => void)} fn\n * @returns {import('#client').Effect}\n */\nexport function legacy_pre_effect(deps, fn) {\n\tconst component_context = /** @type {import('#client').ComponentContext} */ (\n\t\tcurrent_component_context\n\t);\n\tconst token = {};\n\treturn create_effect(\n\t\tPRE_EFFECT,\n\t\t() => {\n\t\t\tdeps();\n\t\t\tif (component_context.l1.includes(token)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcomponent_context.l1.push(token);\n\t\t\tset(component_context.l2, true);\n\t\t\treturn untrack(fn);\n\t\t},\n\t\ttrue\n\t);\n}\n\nexport function legacy_pre_effect_reset() {\n\tconst component_context = /** @type {import('#client').ComponentContext} */ (\n\t\tcurrent_component_context\n\t);\n\treturn render_effect(() => {\n\t\tconst x = get(component_context.l2);\n\t\tif (x) {\n\t\t\tcomponent_context.l1.length = 0;\n\t\t\tcomponent_context.l2.v = false; // set directly to avoid rerunning this effect\n\t\t}\n\t});\n}\n\n/**\n * This effect is used to ensure binding are kept in sync. We use a pre effect to ensure we run before the\n * bindings which are in later effects. However, we don't use a pre_effect directly as we don't want to flush anything.\n *\n * @param {() => void | (() => void)} fn\n * @returns {import('#client').Effect}\n */\nexport function invalidate_effect(fn) {\n\treturn create_effect(PRE_EFFECT, fn, true);\n}\n\n/**\n * @template {import('#client').Block} B\n * @param {(block: B) => void | (() => void)} fn\n * @param {any} block\n * @param {any} managed\n * @param {any} sync\n * @returns {import('#client').Effect}\n */\nexport function render_effect(fn, block = current_block, managed = false, sync = true) {\n\tlet flags = RENDER_EFFECT;\n\tif (managed) {\n\t\tflags |= MANAGED;\n\t}\n\treturn create_effect(flags, /** @type {any} */ (fn), sync, block);\n}\n\n/**\n * @param {import('#client').Effect} signal\n * @returns {void}\n */\nexport function destroy_effect(signal) {\n\tdestroy_children(signal);\n\tremove_reactions(signal, 0);\n\tset_signal_status(signal, DESTROYED);\n\n\tsignal.teardown?.();\n\tsignal.ondestroy?.();\n\tsignal.fn =\n\t\tsignal.effects =\n\t\tsignal.teardown =\n\t\tsignal.ondestroy =\n\t\tsignal.ctx =\n\t\tsignal.block =\n\t\tsignal.deps =\n\t\t\tnull;\n}\n","import { DEV } from 'esm-env';\nimport { CLEAN, DERIVED, DESTROYED, DIRTY, MAYBE_DIRTY, UNOWNED } from '../constants.js';\nimport {\n\tcurrent_reaction,\n\tcurrent_effect,\n\tdestroy_children,\n\tremove_reactions,\n\tset_signal_status,\n\tmark_reactions,\n\tcurrent_skip_reaction,\n\texecute_reaction_fn\n} from '../runtime.js';\nimport { equals, safe_equals } from './equality.js';\n\nexport let updating_derived = false;\n\n/**\n * @template V\n * @param {() => V} fn\n * @returns {import('#client').Derived<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function derived(fn) {\n\tlet flags = DERIVED | DIRTY;\n\tif (current_effect === null) flags |= UNOWNED;\n\n\t/** @type {import('#client').Derived<V>} */\n\tconst signal = {\n\t\treactions: null,\n\t\tdeps: null,\n\t\tequals,\n\t\tf: flags,\n\t\tfn,\n\t\teffects: null,\n\t\tderiveds: null,\n\t\tv: /** @type {V} */ (null),\n\t\tversion: 0\n\t};\n\n\tif (DEV) {\n\t\t/** @type {import('#client').DerivedDebug} */ (signal).inspect = new Set();\n\t}\n\n\tif (current_reaction !== null) {\n\t\tif (current_reaction.deriveds === null) {\n\t\t\tcurrent_reaction.deriveds = [signal];\n\t\t} else {\n\t\t\tcurrent_reaction.deriveds.push(signal);\n\t\t}\n\t}\n\n\treturn signal;\n}\n\n/**\n * @template V\n * @param {() => V} fn\n * @returns {import('#client').Derived<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function derived_safe_equal(fn) {\n\tconst signal = derived(fn);\n\tsignal.equals = safe_equals;\n\treturn signal;\n}\n\n/**\n * @param {import('#client').Derived} derived\n * @param {boolean} force_schedule\n * @returns {void}\n */\nexport function update_derived(derived, force_schedule) {\n\tvar previous_updating_derived = updating_derived;\n\tupdating_derived = true;\n\tdestroy_children(derived);\n\tvar value = execute_reaction_fn(derived);\n\tupdating_derived = previous_updating_derived;\n\n\tvar status =\n\t\t(current_skip_reaction || (derived.f & UNOWNED) !== 0) && derived.deps !== null\n\t\t\t? MAYBE_DIRTY\n\t\t\t: CLEAN;\n\n\tset_signal_status(derived, status);\n\n\tif (!derived.equals(value)) {\n\t\tderived.v = value;\n\t\tmark_reactions(derived, DIRTY, force_schedule);\n\n\t\tif (DEV && force_schedule) {\n\t\t\tfor (var fn of /** @type {import('#client').DerivedDebug} */ (derived).inspect) fn();\n\t\t}\n\t}\n}\n\n/**\n * @param {import('#client').Derived} signal\n * @returns {void}\n */\nexport function destroy_derived(signal) {\n\tdestroy_children(signal);\n\tremove_reactions(signal, 0);\n\tset_signal_status(signal, DESTROYED);\n\n\tsignal.effects =\n\t\tsignal.deps =\n\t\tsignal.reactions =\n\t\t// @ts-expect-error `signal.fn` cannot be `null` while the signal is alive\n\t\tsignal.fn =\n\t\t\tnull;\n}\n","// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport const noop = () => {};\n\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\n\n/**\n * @template [T=any]\n * @param {any} value\n * @returns {value is PromiseLike<T>}\n */\nexport function is_promise(value) {\n\treturn typeof value?.then === 'function';\n}\n\n/** @param {Array<() => void>} arr */\nexport function run_all(arr) {\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tarr[i]();\n\t}\n}\n\n/** @param {Function} fn */\nexport function run(fn) {\n\treturn fn();\n}\n","import { run_all } from '../../common.js';\n\nlet is_task_queued = false;\nlet is_raf_queued = false;\n\n/** @type {Array<() => void>} */\nlet current_queued_tasks = [];\n/** @type {Array<() => void>} */\nlet current_raf_tasks = [];\n\nfunction process_task() {\n\tis_task_queued = false;\n\tconst tasks = current_queued_tasks.slice();\n\tcurrent_queued_tasks = [];\n\trun_all(tasks);\n}\n\nfunction process_raf_task() {\n\tis_raf_queued = false;\n\tconst tasks = current_raf_tasks.slice();\n\tcurrent_raf_tasks = [];\n\trun_all(tasks);\n}\n\n/**\n * @param {() => void} fn\n * @returns {void}\n */\nexport function schedule_task(fn) {\n\tif (!is_task_queued) {\n\t\tis_task_queued = true;\n\t\tsetTimeout(process_task, 0);\n\t}\n\tcurrent_queued_tasks.push(fn);\n}\n\n/**\n * @param {() => void} fn\n * @returns {void}\n */\nexport function schedule_raf_task(fn) {\n\tif (!is_raf_queued) {\n\t\tis_raf_queued = true;\n\t\trequestAnimationFrame(process_raf_task);\n\t}\n\tcurrent_raf_tasks.push(fn);\n}\n\n/**\n * Synchronously run any queued tasks.\n */\nexport function flush_tasks() {\n\tif (is_task_queued) {\n\t\tprocess_task();\n\t}\n\tif (is_raf_queued) {\n\t\tprocess_raf_task();\n\t}\n}\n","import { DEV } from 'esm-env';\nimport {\n\tarray_prototype,\n\tget_descriptors,\n\tget_prototype_of,\n\tis_frozen,\n\tobject_freeze,\n\tobject_prototype\n} from './utils.js';\nimport { unstate } from './proxy.js';\nimport { destroy_effect, pre_effect } from './reactivity/effects.js';\nimport {\n\tEFFECT,\n\tPRE_EFFECT,\n\tRENDER_EFFECT,\n\tDIRTY,\n\tMAYBE_DIRTY,\n\tCLEAN,\n\tDERIVED,\n\tUNOWNED,\n\tDESTROYED,\n\tINERT,\n\tMANAGED,\n\tSTATE_SYMBOL\n} from './constants.js';\nimport { flush_tasks } from './dom/task.js';\nimport { add_owner } from './dev/ownership.js';\nimport { mutate, set, source } from './reactivity/sources.js';\nimport { destroy_derived, update_derived } from './reactivity/deriveds.js';\n\nconst FLUSH_MICROTASK = 0;\nconst FLUSH_SYNC = 1;\n\n// Used for controlling the flush of effects.\nlet current_scheduler_mode = FLUSH_MICROTASK;\n// Used for handling scheduling\nlet is_micro_task_queued = false;\nlet is_flushing_effect = false;\n// Used for $inspect\nexport let is_batching_effect = false;\nlet is_inspecting_signal = false;\n\n// Handle effect queues\n\n/** @type {import('./types.js').Effect[]} */\nlet current_queued_pre_and_render_effects = [];\n\n/** @type {import('./types.js').Effect[]} */\nlet current_queued_effects = [];\n\nlet flush_count = 0;\n// Handle signal reactivity tree dependencies and reactions\n\n/** @type {null | import('./types.js').Reaction} */\nexport let current_reaction = null;\n\n/** @type {null | import('./types.js').Effect} */\nexport let current_effect = null;\n\n/** @type {null | import('./types.js').Value[]} */\nexport let current_dependencies = null;\nlet current_dependencies_index = 0;\n/**\n * Tracks writes that the effect it's executed in doesn't listen to yet,\n * so that the dependency can be added to the effect later on if it then reads it\n * @type {null | import('./types.js').Source[]}\n */\nexport let current_untracked_writes = null;\n\n/** @param {null | import('./types.js').Source[]} value */\nexport function set_current_untracked_writes(value) {\n\tcurrent_untracked_writes = value;\n}\n\n/** @type {null | import('./types.js').ValueDebug} */\nexport let last_inspected_signal = null;\n\n/** @param {null | import('./types.js').ValueDebug} signal */\nexport function set_last_inspected_signal(signal) {\n\tlast_inspected_signal = signal;\n}\n\n/** If `true`, `get`ting the signal should not register it as a dependency */\nexport let current_untracking = false;\n\n// If we are working with a get() chain that has no active container,\n// to prevent memory leaks, we skip adding the reaction.\nexport let current_skip_reaction = false;\n// Handle collecting all signals which are read during a specific time frame\nexport let is_signals_recorded = false;\nlet captured_signals = new Set();\n\n/** @type {Function | null} */\nexport let inspect_fn = null;\n\n/** @type {Array<import('./types.js').ValueDebug>} */\nlet inspect_captured_signals = [];\n\n// Handle rendering tree blocks and anchors\n/** @type {null | import('./types.js').Block} */\nexport let current_block = null;\n// Handling runtime component context\n\n/** @type {import('./types.js').ComponentContext | null} */\nexport let current_component_context = null;\n\n/** @returns {boolean} */\nexport function is_runes() {\n\treturn current_component_context !== null && current_component_context.r;\n}\n\n/**\n * @param {import('./types.js').ProxyStateObject} target\n * @param {string | symbol} prop\n * @param {any} receiver\n */\nexport function batch_inspect(target, prop, receiver) {\n\tconst value = Reflect.get(target, prop, receiver);\n\t/**\n\t * @this {any}\n\t */\n\treturn function () {\n\t\tconst previously_batching_effect = is_batching_effect;\n\t\tis_batching_effect = true;\n\t\ttry {\n\t\t\treturn Reflect.apply(value, this, arguments);\n\t\t} finally {\n\t\t\tis_batching_effect = previously_batching_effect;\n\t\t\tif (last_inspected_signal !== null && !is_inspecting_signal) {\n\t\t\t\tis_inspecting_signal = true;\n\t\t\t\ttry {\n\t\t\t\t\tfor (const fn of last_inspected_signal.inspect) {\n\t\t\t\t\t\tfn();\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\tis_inspecting_signal = false;\n\t\t\t\t}\n\t\t\t\tlast_inspected_signal = null;\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * Determines whether a derived or effect is dirty.\n * If it is MAYBE_DIRTY, will set the status to CLEAN\n * @param {import('./types.js').Reaction} reaction\n * @returns {boolean}\n */\nfunction check_dirtiness(reaction) {\n\tvar flags = reaction.f;\n\n\tif ((flags & DIRTY) !== 0) {\n\t\treturn true;\n\t}\n\n\tif ((flags & MAYBE_DIRTY) !== 0) {\n\t\tvar dependencies = reaction.deps;\n\n\t\tif (dependencies !== null) {\n\t\t\tvar length = dependencies.length;\n\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tvar dependency = dependencies[i];\n\n\t\t\t\tif (check_dirtiness(/** @type {import('#client').Derived} */ (dependency))) {\n\t\t\t\t\tupdate_derived(/** @type {import('#client').Derived} **/ (dependency), true);\n\n\t\t\t\t\t// `signal` might now be dirty, as a result of calling `update_derived`\n\t\t\t\t\tif ((reaction.f & DIRTY) !== 0) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If we're working with an unowned derived signal, then we need to check\n\t\t\t\t// if our dependency write version is higher. If it is then we can assume\n\t\t\t\t// that state has changed to a newer version and thus this unowned signal\n\t\t\t\t// is also dirty.\n\t\t\t\tvar is_unowned = (flags & UNOWNED) !== 0;\n\t\t\t\tvar version = dependency.version;\n\n\t\t\t\tif (is_unowned && version > /** @type {import('#client').Derived} */ (reaction).version) {\n\t\t\t\t\t/** @type {import('#client').Derived} */ (reaction).version = version;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tset_signal_status(reaction, CLEAN);\n\t}\n\n\treturn false;\n}\n\n/**\n * @template V\n * @param {import('./types.js').Reaction} signal\n * @returns {V}\n */\nexport function execute_reaction_fn(signal) {\n\tconst fn = signal.fn;\n\tconst flags = signal.f;\n\tconst is_render_effect = (flags & RENDER_EFFECT) !== 0;\n\n\tconst previous_dependencies = current_dependencies;\n\tconst previous_dependencies_index = current_dependencies_index;\n\tconst previous_untracked_writes = current_untracked_writes;\n\tconst previous_reaction = current_reaction;\n\tconst previous_skip_reaction = current_skip_reaction;\n\tconst previous_untracking = current_untracking;\n\n\tcurrent_dependencies = /** @type {null | import('./types.js').Value[]} */ (null);\n\tcurrent_dependencies_index = 0;\n\tcurrent_untracked_writes = null;\n\tcurrent_reaction = signal;\n\tcurrent_skip_reaction = !is_flushing_effect && (flags & UNOWNED) !== 0;\n\tcurrent_untracking = false;\n\n\ttry {\n\t\tlet res;\n\t\tif (is_render_effect) {\n\t\t\tres = /** @type {(block: import('#client').Block, signal: import('#client').Signal) => V} */ (\n\t\t\t\tfn\n\t\t\t)(\n\t\t\t\t/** @type {import('#client').Block} */ (\n\t\t\t\t\t/** @type {import('#client').Effect} */ (signal).block\n\t\t\t\t),\n\t\t\t\t/** @type {import('#client').Signal} */ (signal)\n\t\t\t);\n\t\t} else {\n\t\t\tres = /** @type {() => V} */ (fn)();\n\t\t}\n\t\tlet dependencies = /** @type {import('./types.js').Value<unknown>[]} **/ (signal.deps);\n\t\tif (current_dependencies !== null) {\n\t\t\tlet i;\n\t\t\tif (dependencies !== null) {\n\t\t\t\tconst deps_length = dependencies.length;\n\t\t\t\t// Include any dependencies up until the current_dependencies_index.\n\t\t\t\tconst full_current_dependencies =\n\t\t\t\t\tcurrent_dependencies_index === 0\n\t\t\t\t\t\t? current_dependencies\n\t\t\t\t\t\t: dependencies.slice(0, current_dependencies_index).concat(current_dependencies);\n\t\t\t\tconst current_dep_length = full_current_dependencies.length;\n\t\t\t\t// If we have more than 16 elements in the array then use a Set for faster performance\n\t\t\t\t// TODO: evaluate if we should always just use a Set or not here?\n\t\t\t\tconst full_current_dependencies_set =\n\t\t\t\t\tcurrent_dep_length > 16 && deps_length - current_dependencies_index > 1\n\t\t\t\t\t\t? new Set(full_current_dependencies)\n\t\t\t\t\t\t: null;\n\t\t\t\tfor (i = current_dependencies_index; i < deps_length; i++) {\n\t\t\t\t\tconst dependency = dependencies[i];\n\t\t\t\t\tif (\n\t\t\t\t\t\tfull_current_dependencies_set !== null\n\t\t\t\t\t\t\t? !full_current_dependencies_set.has(dependency)\n\t\t\t\t\t\t\t: !full_current_dependencies.includes(dependency)\n\t\t\t\t\t) {\n\t\t\t\t\t\tremove_reaction(signal, dependency);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dependencies !== null && current_dependencies_index > 0) {\n\t\t\t\tdependencies.length = current_dependencies_index + current_dependencies.length;\n\t\t\t\tfor (i = 0; i < current_dependencies.length; i++) {\n\t\t\t\t\tdependencies[current_dependencies_index + i] = current_dependencies[i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsignal.deps = /** @type {import('./types.js').Value<V>[]} **/ (\n\t\t\t\t\tdependencies = current_dependencies\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (!current_skip_reaction) {\n\t\t\t\tfor (i = current_dependencies_index; i < dependencies.length; i++) {\n\t\t\t\t\tconst dependency = dependencies[i];\n\t\t\t\t\tconst reactions = dependency.reactions;\n\n\t\t\t\t\tif (reactions === null) {\n\t\t\t\t\t\tdependency.reactions = [signal];\n\t\t\t\t\t} else if (reactions[reactions.length - 1] !== signal) {\n\t\t\t\t\t\t// TODO: should this be:\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// } else if (!reactions.includes(signal)) {\n\t\t\t\t\t\t//\n\t\t\t\t\t\treactions.push(signal);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (dependencies !== null && current_dependencies_index < dependencies.length) {\n\t\t\tremove_reactions(signal, current_dependencies_index);\n\t\t\tdependencies.length = current_dependencies_index;\n\t\t}\n\t\treturn res;\n\t} finally {\n\t\tcurrent_dependencies = previous_dependencies;\n\t\tcurrent_dependencies_index = previous_dependencies_index;\n\t\tcurrent_untracked_writes = previous_untracked_writes;\n\t\tcurrent_reaction = previous_reaction;\n\t\tcurrent_skip_reaction = previous_skip_reaction;\n\t\tcurrent_untracking = previous_untracking;\n\t}\n}\n\n/**\n * @template V\n * @param {import('./types.js').Reaction} signal\n * @param {import('./types.js').Value<V>} dependency\n * @returns {void}\n */\nfunction remove_reaction(signal, dependency) {\n\tconst reactions = dependency.reactions;\n\tlet reactions_length = 0;\n\tif (reactions !== null) {\n\t\treactions_length = reactions.length - 1;\n\t\tconst index = reactions.indexOf(signal);\n\t\tif (index !== -1) {\n\t\t\tif (reactions_length === 0) {\n\t\t\t\tdependency.reactions = null;\n\t\t\t} else {\n\t\t\t\t// Swap with last element and then remove.\n\t\t\t\treactions[index] = reactions[reactions_length];\n\t\t\t\treactions.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (reactions_length === 0 && (dependency.f & UNOWNED) !== 0) {\n\t\t// If the signal is unowned then we need to make sure to change it to dirty.\n\t\tset_signal_status(dependency, DIRTY);\n\t\tremove_reactions(/** @type {import('./types.js').Derived} **/ (dependency), 0);\n\t}\n}\n\n/**\n * @param {import('./types.js').Reaction} signal\n * @param {number} start_index\n * @returns {void}\n */\nexport function remove_reactions(signal, start_index) {\n\tconst dependencies = signal.deps;\n\tif (dependencies !== null) {\n\t\tconst active_dependencies = start_index === 0 ? null : dependencies.slice(0, start_index);\n\t\tlet i;\n\t\tfor (i = start_index; i < dependencies.length; i++) {\n\t\t\tconst dependency = dependencies[i];\n\t\t\t// Avoid removing a reaction if we know that it is active (start_index will not be 0)\n\t\t\tif (active_dependencies === null || !active_dependencies.includes(dependency)) {\n\t\t\t\tremove_reaction(signal, dependency);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @param {import('./types.js').Reaction} signal\n * @returns {void}\n */\nexport function destroy_children(signal) {\n\tif (signal.effects) {\n\t\tfor (var i = 0; i < signal.effects.length; i += 1) {\n\t\t\tvar effect = signal.effects[i];\n\t\t\tif ((effect.f & MANAGED) === 0) {\n\t\t\t\tdestroy_effect(effect);\n\t\t\t}\n\t\t}\n\t\tsignal.effects = null;\n\t}\n\n\tif (signal.deriveds) {\n\t\tfor (i = 0; i < signal.deriveds.length; i += 1) {\n\t\t\tdestroy_derived(signal.deriveds[i]);\n\t\t}\n\t\tsignal.deriveds = null;\n\t}\n}\n\n/**\n * @param {import('./types.js').Effect} signal\n * @returns {void}\n */\nexport function execute_effect(signal) {\n\tif ((signal.f & DESTROYED) !== 0) {\n\t\treturn;\n\t}\n\n\tconst previous_effect = current_effect;\n\tconst previous_component_context = current_component_context;\n\tconst previous_block = current_block;\n\n\tconst component_context = signal.ctx;\n\n\tcurrent_effect = signal;\n\tcurrent_component_context = component_context;\n\tcurrent_block = signal.block;\n\n\ttry {\n\t\tdestroy_children(signal);\n\t\tsignal.teardown?.();\n\t\tconst teardown = execute_reaction_fn(signal);\n\t\tsignal.teardown = typeof teardown === 'function' ? teardown : null;\n\t} finally {\n\t\tcurrent_effect = previous_effect;\n\t\tcurrent_component_context = previous_component_context;\n\t\tcurrent_block = previous_block;\n\t}\n\n\tif ((signal.f & PRE_EFFECT) !== 0 && current_queued_pre_and_render_effects.length > 0) {\n\t\tflush_local_pre_effects(component_context);\n\t}\n}\n\nfunction infinite_loop_guard() {\n\tif (flush_count > 100) {\n\t\tflush_count = 0;\n\t\tthrow new Error(\n\t\t\t'ERR_SVELTE_TOO_MANY_UPDATES' +\n\t\t\t\t(DEV\n\t\t\t\t\t? ': Maximum update depth exceeded. This can happen when a reactive block or effect ' +\n\t\t\t\t\t\t'repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops.'\n\t\t\t\t\t: '')\n\t\t);\n\t}\n\tflush_count++;\n}\n\n/**\n * @param {Array<import('./types.js').Effect>} effects\n * @returns {void}\n */\nfunction flush_queued_effects(effects) {\n\tvar length = effects.length;\n\tif (length === 0) return;\n\n\tinfinite_loop_guard();\n\tvar previously_flushing_effect = is_flushing_effect;\n\tis_flushing_effect = true;\n\n\ttry {\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar signal = effects[i];\n\n\t\t\tif ((signal.f & (DESTROYED | INERT)) === 0) {\n\t\t\t\tif (check_dirtiness(signal)) {\n\t\t\t\t\tset_signal_status(signal, CLEAN);\n\t\t\t\t\texecute_effect(signal);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} finally {\n\t\tis_flushing_effect = previously_flushing_effect;\n\t}\n\n\teffects.length = 0;\n}\n\nfunction process_microtask() {\n\tis_micro_task_queued = false;\n\tif (flush_count > 101) {\n\t\treturn;\n\t}\n\tconst previous_queued_pre_and_render_effects = current_queued_pre_and_render_effects;\n\tconst previous_queued_effects = current_queued_effects;\n\tcurrent_queued_pre_and_render_effects = [];\n\tcurrent_queued_effects = [];\n\tflush_queued_effects(previous_queued_pre_and_render_effects);\n\tflush_queued_effects(previous_queued_effects);\n\tif (!is_micro_task_queued) {\n\t\tflush_count = 0;\n\t}\n}\n\n/**\n * @param {import('./types.js').Effect} signal\n * @param {boolean} sync\n * @returns {void}\n */\nexport function schedule_effect(signal, sync) {\n\tconst flags = signal.f;\n\tif (sync) {\n\t\tconst previously_flushing_effect = is_flushing_effect;\n\t\ttry {\n\t\t\tis_flushing_effect = true;\n\t\t\texecute_effect(signal);\n\t\t\tset_signal_status(signal, CLEAN);\n\t\t} finally {\n\t\t\tis_flushing_effect = previously_flushing_effect;\n\t\t}\n\t} else {\n\t\tif (current_scheduler_mode === FLUSH_MICROTASK) {\n\t\t\tif (!is_micro_task_queued) {\n\t\t\t\tis_micro_task_queued = true;\n\t\t\t\tqueueMicrotask(process_microtask);\n\t\t\t}\n\t\t}\n\t\tif ((flags & EFFECT) !== 0) {\n\t\t\tcurrent_queued_effects.push(signal);\n\t\t\t// Prevent any nested user effects from potentially triggering\n\t\t\t// before this effect is scheduled. We know they will be destroyed\n\t\t\t// so we can make them inert to avoid having to find them in the\n\t\t\t// queue and remove them.\n\t\t\tif ((flags & MANAGED) === 0) {\n\t\t\t\tmark_subtree_children_inert(signal, true);\n\t\t\t}\n\t\t} else {\n\t\t\t// We need to ensure we insert the signal in the right topological order. In other words,\n\t\t\t// we need to evaluate where to insert the signal based off its level and whether or not it's\n\t\t\t// a pre-effect and within the same block. By checking the signals in the queue in reverse order\n\t\t\t// we can find the right place quickly. TODO: maybe opt to use a linked list rather than an array\n\t\t\t// for these operations.\n\t\t\tconst length = current_queued_pre_and_render_effects.length;\n\t\t\tlet should_append = length === 0;\n\n\t\t\tif (!should_append) {\n\t\t\t\tconst target_level = signal.l;\n\t\t\t\tconst target_block = signal.block;\n\t\t\t\tconst is_pre_effect = (flags & PRE_EFFECT) !== 0;\n\t\t\t\tlet target_signal;\n\t\t\t\tlet target_signal_level;\n\t\t\t\tlet is_target_pre_effect;\n\t\t\t\tlet i = length;\n\t\t\t\twhile (true) {\n\t\t\t\t\ttarget_signal = current_queued_pre_and_render_effects[--i];\n\t\t\t\t\ttarget_signal_level = target_signal.l;\n\t\t\t\t\tif (target_signal_level <= target_level) {\n\t\t\t\t\t\tif (i + 1 === length) {\n\t\t\t\t\t\t\tshould_append = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tis_target_pre_effect = (target_signal.f & PRE_EFFECT) !== 0;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\ttarget_signal_level < target_level ||\n\t\t\t\t\t\t\t\ttarget_signal.block !== target_block ||\n\t\t\t\t\t\t\t\t(is_target_pre_effect && !is_pre_effect)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcurrent_queued_pre_and_render_effects.splice(i, 0, signal);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\tcurrent_queued_pre_and_render_effects.unshift(signal);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (should_append) {\n\t\t\t\tcurrent_queued_pre_and_render_effects.push(signal);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @returns {void}\n */\nexport function flush_local_render_effects() {\n\tconst effects = [];\n\tfor (let i = 0; i < current_queued_pre_and_render_effects.length; i++) {\n\t\tconst effect = current_queued_pre_and_render_effects[i];\n\t\tif ((effect.f & RENDER_EFFECT) !== 0 && effect.ctx === current_component_context) {\n\t\t\teffects.push(effect);\n\t\t\tcurrent_queued_pre_and_render_effects.splice(i, 1);\n\t\t\ti--;\n\t\t}\n\t}\n\tflush_queued_effects(effects);\n}\n\n/**\n * @param {null | import('./types.js').ComponentContext} context\n * @returns {void}\n */\nexport function flush_local_pre_effects(context) {\n\tconst effects = [];\n\tfor (let i = 0; i < current_queued_pre_and_render_effects.length; i++) {\n\t\tconst effect = current_queued_pre_and_render_effects[i];\n\t\tif ((effect.f & PRE_EFFECT) !== 0 && effect.ctx === context) {\n\t\t\teffects.push(effect);\n\t\t\tcurrent_queued_pre_and_render_effects.splice(i, 1);\n\t\t\ti--;\n\t\t}\n\t}\n\tflush_queued_effects(effects);\n}\n\n/**\n * Synchronously flushes any pending state changes and those that result from it.\n * @param {() => void} [fn]\n * @returns {void}\n */\nexport function flushSync(fn) {\n\tflush_sync(fn);\n}\n\n/**\n * Internal version of `flushSync` with the option to not flush previous effects.\n * Returns the result of the passed function, if given.\n * @param {() => any} [fn]\n * @param {boolean} [flush_previous]\n * @returns {any}\n */\nexport function flush_sync(fn, flush_previous = true) {\n\tconst previous_scheduler_mode = current_scheduler_mode;\n\tconst previous_queued_pre_and_render_effects = current_queued_pre_and_render_effects;\n\tconst previous_queued_effects = current_queued_effects;\n\tlet result;\n\n\ttry {\n\t\tinfinite_loop_guard();\n\t\t/** @type {import('./types.js').Effect[]} */\n\t\tconst pre_and_render_effects = [];\n\n\t\t/** @type {import('./types.js').Effect[]} */\n\t\tconst effects = [];\n\t\tcurrent_scheduler_mode = FLUSH_SYNC;\n\t\tcurrent_queued_pre_and_render_effects = pre_and_render_effects;\n\t\tcurrent_queued_effects = effects;\n\t\tif (flush_previous) {\n\t\t\tflush_queued_effects(previous_queued_pre_and_render_effects);\n\t\t\tflush_queued_effects(previous_queued_effects);\n\t\t}\n\t\tif (fn !== undefined) {\n\t\t\tresult = fn();\n\t\t}\n\t\tif (current_queued_pre_and_render_effects.length > 0 || effects.length > 0) {\n\t\t\tflushSync();\n\t\t}\n\t\tflush_tasks();\n\t\tflush_count = 0;\n\t} finally {\n\t\tcurrent_scheduler_mode = previous_scheduler_mode;\n\t\tcurrent_queued_pre_and_render_effects = previous_queued_pre_and_render_effects;\n\t\tcurrent_queued_effects = previous_queued_effects;\n\t}\n\n\treturn result;\n}\n\n/**\n * Returns a promise that resolves once any pending state changes have been applied.\n * @returns {Promise<void>}\n */\nexport async function tick() {\n\tawait Promise.resolve();\n\t// By calling flushSync we guarantee that any pending state changes are applied after one tick.\n\t// TODO look into whether we can make flushing subsequent updates synchronously in the future.\n\tflushSync();\n}\n\n/**\n * @template V\n * @param {import('./types.js').Value<V>} signal\n * @returns {V}\n */\nexport function get(signal) {\n\t// @ts-expect-error\n\tif (DEV && signal.inspect && inspect_fn) {\n\t\t/** @type {import('./types.js').ValueDebug} */ (signal).inspect.add(inspect_fn);\n\t\t// @ts-expect-error\n\t\tinspect_captured_signals.push(signal);\n\t}\n\n\tconst flags = signal.f;\n\tif ((flags & DESTROYED) !== 0) {\n\t\treturn signal.v;\n\t}\n\n\tif (is_signals_recorded) {\n\t\tcaptured_signals.add(signal);\n\t}\n\n\t// Register the dependency on the current reaction signal.\n\tif (current_reaction !== null && (current_reaction.f & MANAGED) === 0 && !current_untracking) {\n\t\tconst unowned = (current_reaction.f & UNOWNED) !== 0;\n\t\tconst dependencies = current_reaction.deps;\n\t\tif (\n\t\t\tcurrent_dependencies === null &&\n\t\t\tdependencies !== null &&\n\t\t\tdependencies[current_dependencies_index] === signal &&\n\t\t\t!(unowned && current_effect !== null)\n\t\t) {\n\t\t\tcurrent_dependencies_index++;\n\t\t} else if (\n\t\t\tdependencies === null ||\n\t\t\tcurrent_dependencies_index === 0 ||\n\t\t\tdependencies[current_dependencies_index - 1] !== signal\n\t\t) {\n\t\t\tif (current_dependencies === null) {\n\t\t\t\tcurrent_dependencies = [signal];\n\t\t\t} else {\n\t\t\t\tcurrent_dependencies.push(signal);\n\t\t\t}\n\t\t}\n\t\tif (\n\t\t\tcurrent_untracked_writes !== null &&\n\t\t\tcurrent_effect !== null &&\n\t\t\t(current_effect.f & CLEAN) !== 0 &&\n\t\t\t(current_effect.f & MANAGED) === 0 &&\n\t\t\tcurrent_untracked_writes.includes(signal)\n\t\t) {\n\t\t\tset_signal_status(current_effect, DIRTY);\n\t\t\tschedule_effect(current_effect, false);\n\t\t}\n\t}\n\n\tif (\n\t\t(flags & DERIVED) !== 0 &&\n\t\tcheck_dirtiness(/** @type {import('#client').Derived} */ (signal))\n\t) {\n\t\tif (DEV) {\n\t\t\t// we want to avoid tracking indirect dependencies\n\t\t\tconst previous_inspect_fn = inspect_fn;\n\t\t\tinspect_fn = null;\n\t\t\tupdate_derived(/** @type {import('./types.js').Derived} **/ (signal), false);\n\t\t\tinspect_fn = previous_inspect_fn;\n\t\t} else {\n\t\t\tupdate_derived(/** @type {import('./types.js').Derived} **/ (signal), false);\n\t\t}\n\t}\n\treturn signal.v;\n}\n\n/**\n * Invokes a function and captures all signals that are read during the invocation,\n * then invalidates them.\n * @param {() => any} fn\n */\nexport function invalidate_inner_signals(fn) {\n\tvar previous_is_signals_recorded = is_signals_recorded;\n\tvar previous_captured_signals = captured_signals;\n\tis_signals_recorded = true;\n\tcaptured_signals = new Set();\n\tvar captured = captured_signals;\n\tvar signal;\n\ttry {\n\t\tuntrack(fn);\n\t} finally {\n\t\tis_signals_recorded = previous_is_signals_recorded;\n\t\tif (is_signals_recorded) {\n\t\t\tfor (signal of captured_signals) {\n\t\t\t\tprevious_captured_signals.add(signal);\n\t\t\t}\n\t\t}\n\t\tcaptured_signals = previous_captured_signals;\n\t}\n\tfor (signal of captured) {\n\t\tmutate(signal, null /* doesnt matter */);\n\t}\n}\n\n/**\n * @param {import('#client').Effect} signal\n * @param {boolean} inert\n * @returns {void}\n */\nfunction mark_subtree_children_inert(signal, inert) {\n\tconst effects = signal.effects;\n\n\tif (effects !== null) {\n\t\tfor (var i = 0; i < effects.length; i++) {\n\t\t\tmark_subtree_inert(effects[i], inert);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('#client').Effect} signal\n * @param {boolean} inert\n * @returns {void}\n */\nexport function mark_subtree_inert(signal, inert) {\n\tconst flags = signal.f;\n\tconst is_already_inert = (flags & INERT) !== 0;\n\n\tif (is_already_inert !== inert) {\n\t\tsignal.f ^= INERT;\n\t\tif (!inert && (flags & CLEAN) === 0) {\n\t\t\tschedule_effect(signal, false);\n\t\t}\n\t}\n\n\tmark_subtree_children_inert(signal, inert);\n}\n\n/**\n * @param {import('#client').Value} signal\n * @param {number} to_status\n * @param {boolean} force_schedule\n * @returns {void}\n */\nexport function mark_reactions(signal, to_status, force_schedule) {\n\tvar reactions = signal.reactions;\n\tif (reactions === null) return;\n\n\tvar runes = is_runes();\n\tvar length = reactions.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar reaction = reactions[i];\n\n\t\t// We skip any effects that are already dirty (but not unowned). Additionally, we also\n\t\t// skip if the reaction is the same as the current effect (except if we're not in runes or we\n\t\t// are in force schedule mode).\n\t\tif ((!force_schedule || !runes) && reaction === current_effect) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar flags = reaction.f;\n\t\tset_signal_status(reaction, to_status);\n\n\t\t// If the signal is not clean, then skip over it â€“ with the exception of unowned signals that\n\t\t// are already maybe dirty. Unowned signals might be dirty because they are not captured as part of an\n\t\t// effect.\n\t\tvar maybe_dirty = (flags & MAYBE_DIRTY) !== 0;\n\t\tvar unowned = (flags & UNOWNED) !== 0;\n\n\t\tif ((flags & CLEAN) !== 0 || (maybe_dirty && unowned)) {\n\t\t\tif ((reaction.f & DERIVED) !== 0) {\n\t\t\t\tmark_reactions(\n\t\t\t\t\t/** @type {import('#client').Derived} */ (reaction),\n\t\t\t\t\tMAYBE_DIRTY,\n\t\t\t\t\tforce_schedule\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tschedule_effect(/** @type {import('#client').Effect} */ (reaction), false);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Use `untrack` to prevent something from being treated as an `$effect`/`$derived` dependency.\n *\n * https://svelte-5-preview.vercel.app/docs/functions#untrack\n * @template T\n * @param {() => T} fn\n * @returns {T}\n */\nexport function untrack(fn) {\n\tconst previous_untracking = current_untracking;\n\ttry {\n\t\tcurrent_untracking = true;\n\t\treturn fn();\n\t} finally {\n\t\tcurrent_untracking = previous_untracking;\n\t}\n}\n\nconst STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);\n\n/**\n * @param {import('./types.js').Signal} signal\n * @param {number} status\n * @returns {void}\n */\nexport function set_signal_status(signal, status) {\n\tsignal.f = (signal.f & STATUS_MASK) | status;\n}\n\n/**\n * @template V\n * @param {V | import('./types.js').Value<V>} val\n * @returns {val is import('./types.js').Value<V>}\n */\nexport function is_signal(val) {\n\treturn (\n\t\ttypeof val === 'object' &&\n\t\tval !== null &&\n\t\ttypeof (/** @type {import('./types.js').Value<V>} */ (val).f) === 'number'\n\t);\n}\n\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#getcontext\n * @template T\n * @param {any} key\n * @returns {T}\n */\nexport function getContext(key) {\n\tconst context_map = get_or_init_context_map();\n\tconst result = /** @type {T} */ (context_map.get(key));\n\n\tif (DEV) {\n\t\t// @ts-expect-error\n\t\tconst fn = current_component_context?.function;\n\t\tif (fn) {\n\t\t\tadd_owner(result, fn);\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#setcontext\n * @template T\n * @param {any} key\n * @param {T} context\n * @returns {T}\n */\nexport function setContext(key, context) {\n\tconst context_map = get_or_init_context_map();\n\tcontext_map.set(key, context);\n\treturn context;\n}\n\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#hascontext\n * @param {any} key\n * @returns {boolean}\n */\nexport function hasContext(key) {\n\tconst context_map = get_or_init_context_map();\n\treturn context_map.has(key);\n}\n\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs/svelte#getallcontexts\n * @template {Map<any, any>} [T=Map<any, any>]\n * @returns {T}\n */\nexport function getAllContexts() {\n\tconst context_map = get_or_init_context_map();\n\n\tif (DEV) {\n\t\t// @ts-expect-error\n\t\tconst fn = current_component_context?.function;\n\t\tif (fn) {\n\t\t\tfor (const value of context_map.values()) {\n\t\t\t\tadd_owner(value, fn);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn /** @type {T} */ (context_map);\n}\n\n/** @returns {Map<unknown, unknown>} */\nfunction get_or_init_context_map() {\n\tconst component_context = current_component_context;\n\tif (component_context === null) {\n\t\tthrow new Error(\n\t\t\t'ERR_SVELTE_ORPHAN_CONTEXT' +\n\t\t\t\t(DEV ? 'Context can only be used during component initialisation.' : '')\n\t\t);\n\t}\n\treturn (component_context.c ??= new Map(get_parent_context(component_context) || undefined));\n}\n\n/**\n * @param {import('./types.js').ComponentContext} component_context\n * @returns {Map<unknown, unknown> | null}\n */\nfunction get_parent_context(component_context) {\n\tlet parent = component_context.p;\n\twhile (parent !== null) {\n\t\tconst context_map = parent.c;\n\t\tif (context_map !== null) {\n\t\t\treturn context_map;\n\t\t}\n\t\tparent = parent.p;\n\t}\n\treturn null;\n}\n\n/**\n * @param {import('./types.js').Value<number>} signal\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update(signal, d = 1) {\n\tconst value = get(signal);\n\tset(signal, value + d);\n\treturn value;\n}\n\n/**\n * @param {import('./types.js').Value<number>} signal\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre(signal, d = 1) {\n\tconst value = get(signal) + d;\n\tset(signal, value);\n\treturn value;\n}\n\n/**\n * @param {Record<string, unknown>} obj\n * @param {string[]} keys\n * @returns {Record<string, unknown>}\n */\nexport function exclude_from_object(obj, keys) {\n\tobj = { ...obj };\n\tlet key;\n\tfor (key of keys) {\n\t\tdelete obj[key];\n\t}\n\treturn obj;\n}\n\n/**\n * @template V\n * @param {V} value\n * @param {V} fallback\n * @returns {V}\n */\nexport function value_or_fallback(value, fallback) {\n\treturn value === undefined ? fallback : value;\n}\n\n/**\n * @param {Record<string, unknown>} props\n * @param {any} runes\n * @param {Function} [fn]\n * @returns {void}\n */\nexport function push(props, runes = false, fn) {\n\tcurrent_component_context = {\n\t\t// exports (and props, if `accessors: true`)\n\t\tx: null,\n\t\t// context\n\t\tc: null,\n\t\t// effects\n\t\te: null,\n\t\t// mounted\n\t\tm: false,\n\t\t// parent\n\t\tp: current_component_context,\n\t\t// signals\n\t\td: null,\n\t\t// props\n\t\ts: props,\n\t\t// runes\n\t\tr: runes,\n\t\t// legacy $:\n\t\tl1: [],\n\t\tl2: source(false),\n\t\t// update_callbacks\n\t\tu: null\n\t};\n\n\tif (DEV) {\n\t\t// component function\n\t\t// @ts-expect-error\n\t\tcurrent_component_context.function = fn;\n\t}\n}\n\n/**\n * @template {Record<string, any>} T\n * @param {T} [component]\n * @returns {T}\n */\nexport function pop(component) {\n\tconst context_stack_item = current_component_context;\n\tif (context_stack_item !== null) {\n\t\tif (component !== undefined) {\n\t\t\tcontext_stack_item.x = component;\n\t\t}\n\t\tconst effects = context_stack_item.e;\n\t\tif (effects !== null) {\n\t\t\tcontext_stack_item.e = null;\n\t\t\tfor (let i = 0; i < effects.length; i++) {\n\t\t\t\tschedule_effect(effects[i], false);\n\t\t\t}\n\t\t}\n\t\tcurrent_component_context = context_stack_item.p;\n\t\tcontext_stack_item.m = true;\n\t}\n\t// Micro-optimization: Don't set .a above to the empty object\n\t// so it can be garbage-collected when the return here is unused\n\treturn component || /** @type {T} */ ({});\n}\n\n/**\n * Possibly traverse an object and read all its properties so that they're all reactive in case this is `$state`.\n * Does only check first level of an object for performance reasons (heuristic should be good for 99% of all cases).\n * @param {any} value\n * @returns {void}\n */\nexport function deep_read_state(value) {\n\tif (typeof value !== 'object' || !value || value instanceof EventTarget) {\n\t\treturn;\n\t}\n\n\tif (STATE_SYMBOL in value) {\n\t\tdeep_read(value);\n\t} else if (!Array.isArray(value)) {\n\t\tfor (let key in value) {\n\t\t\tconst prop = value[key];\n\t\t\tif (typeof prop === 'object' && prop && STATE_SYMBOL in prop) {\n\t\t\t\tdeep_read(prop);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Deeply traverse an object and read all its properties\n * so that they're all reactive in case this is `$state`\n * @param {any} value\n * @param {Set<any>} visited\n * @returns {void}\n */\nexport function deep_read(value, visited = new Set()) {\n\tif (\n\t\ttypeof value === 'object' &&\n\t\tvalue !== null &&\n\t\t// We don't want to traverse DOM elements\n\t\t!(value instanceof EventTarget) &&\n\t\t!visited.has(value)\n\t) {\n\t\tvisited.add(value);\n\t\tfor (let key in value) {\n\t\t\ttry {\n\t\t\t\tdeep_read(value[key], visited);\n\t\t\t} catch (e) {\n\t\t\t\t// continue\n\t\t\t}\n\t\t}\n\t\tconst proto = Object.getPrototypeOf(value);\n\t\tif (\n\t\t\tproto !== Object.prototype &&\n\t\t\tproto !== Array.prototype &&\n\t\t\tproto !== Map.prototype &&\n\t\t\tproto !== Set.prototype &&\n\t\t\tproto !== Date.prototype\n\t\t) {\n\t\t\tconst descriptors = get_descriptors(proto);\n\t\t\tfor (let key in descriptors) {\n\t\t\t\tconst get = descriptors[key].get;\n\t\t\t\tif (get) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tget.call(value);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t// continue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Like `unstate`, but recursively traverses into normal arrays/objects to find potential states in them.\n * @param {any} value\n * @param {Map<any, any>} visited\n * @returns {any}\n */\nfunction deep_unstate(value, visited = new Map()) {\n\tif (typeof value === 'object' && value !== null && !visited.has(value)) {\n\t\tconst unstated = unstate(value);\n\t\tif (unstated !== value) {\n\t\t\tvisited.set(value, unstated);\n\t\t\treturn unstated;\n\t\t}\n\t\tconst prototype = get_prototype_of(value);\n\t\t// Only deeply unstate plain objects and arrays\n\t\tif (prototype === object_prototype || prototype === array_prototype) {\n\t\t\tlet contains_unstated = false;\n\t\t\t/** @type {any} */\n\t\t\tconst nested_unstated = Array.isArray(value) ? [] : {};\n\t\t\tfor (let key in value) {\n\t\t\t\tconst result = deep_unstate(value[key], visited);\n\t\t\t\tnested_unstated[key] = result;\n\t\t\t\tif (result !== value[key]) {\n\t\t\t\t\tcontains_unstated = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvisited.set(value, contains_unstated ? nested_unstated : value);\n\t\t} else {\n\t\t\tvisited.set(value, value);\n\t\t}\n\t}\n\n\treturn visited.get(value) ?? value;\n}\n\n// TODO remove in a few versions, before 5.0 at the latest\nlet warned_inspect_changed = false;\n\n/**\n * @param {() => any[]} get_value\n * @param {Function} [inspect]\n */\n// eslint-disable-next-line no-console\nexport function inspect(get_value, inspect = console.log) {\n\tlet initial = true;\n\n\tpre_effect(() => {\n\t\tconst fn = () => {\n\t\t\tconst value = untrack(() => get_value().map((v) => deep_unstate(v)));\n\t\t\tif (value.length === 2 && typeof value[1] === 'function' && !warned_inspect_changed) {\n\t\t\t\t// eslint-disable-next-line no-console\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'$inspect() API has changed. See https://svelte-5-preview.vercel.app/docs/runes#$inspect for more information.'\n\t\t\t\t);\n\t\t\t\twarned_inspect_changed = true;\n\t\t\t}\n\t\t\tinspect(initial ? 'init' : 'update', ...value);\n\t\t};\n\n\t\tinspect_fn = fn;\n\t\tconst value = get_value();\n\t\tdeep_read(value);\n\t\tinspect_fn = null;\n\n\t\tconst signals = inspect_captured_signals.slice();\n\t\tinspect_captured_signals = [];\n\n\t\tif (initial) {\n\t\t\tfn();\n\t\t\tinitial = false;\n\t\t}\n\n\t\treturn () => {\n\t\t\tfor (const s of signals) {\n\t\t\t\ts.inspect.delete(fn);\n\t\t\t}\n\t\t};\n\t});\n}\n\n/**\n * @template V\n * @param {V | import('#client').Value<V>} value\n * @returns {V}\n */\nexport function unwrap(value) {\n\tif (is_signal(value)) {\n\t\t// @ts-ignore\n\t\treturn get(value);\n\t}\n\t// @ts-ignore\n\treturn value;\n}\n\nif (DEV) {\n\t/** @param {string} rune */\n\tfunction throw_rune_error(rune) {\n\t\tif (!(rune in globalThis)) {\n\t\t\t// @ts-ignore\n\t\t\tglobalThis[rune] = () => {\n\t\t\t\t// TODO if people start adjusting the \"this can contain runes\" config through v-p-s more, adjust this message\n\t\t\t\tthrow new Error(`${rune} is only available inside .svelte and .svelte.js/ts files`);\n\t\t\t};\n\t\t}\n\t}\n\n\tthrow_rune_error('$state');\n\tthrow_rune_error('$effect');\n\tthrow_rune_error('$derived');\n\tthrow_rune_error('$inspect');\n\tthrow_rune_error('$props');\n}\n\n/**\n * Expects a value that was wrapped with `freeze` and makes it frozen.\n * @template T\n * @param {T} value\n * @returns {Readonly<T>}\n */\nexport function freeze(value) {\n\tif (typeof value === 'object' && value != null && !is_frozen(value)) {\n\t\t// If the object is already proxified, then unstate the value\n\t\tif (STATE_SYMBOL in value) {\n\t\t\treturn object_freeze(unstate(value));\n\t\t}\n\t\t// Otherwise freeze the object\n\t\tobject_freeze(value);\n\t}\n\treturn value;\n}\n","import { current_hydration_fragment, get_hydration_fragment, hydrating } from './hydration.js';\nimport { get_descriptor } from '../utils.js';\n\n// We cache the Node and Element prototype methods, so that we can avoid doing\n// expensive prototype chain lookups.\n\n/** @type {Node} */\nvar node_prototype;\n\n/** @type {Element} */\nvar element_prototype;\n\n/** @type {Text} */\nvar text_prototype;\n\n/** @type {typeof Node.prototype.appendChild} */\nvar append_child_method;\n\n/** @type {typeof Node.prototype.cloneNode} */\nvar clone_node_method;\n\n/** @type {(this: Node) => ChildNode | null} */\nvar first_child_get;\n\n/** @type {(this: Node) => ChildNode | null} */\nvar next_sibling_get;\n\n/** @type {(this: Node, text: string ) => void} */\nvar text_content_set;\n\n/** @type {(this: Element, class_name: string) => void} */\nvar class_name_set;\n\n// export these for reference in the compiled code, making global name deduplication unnecessary\n/**\n * @type {Window}\n */\nexport var $window;\n/**\n * @type {Document}\n */\nexport var $document;\n\n/**\n * Initialize these lazily to avoid issues when using the runtime in a server context\n * where these globals are not available while avoiding a separate server entry point\n */\nexport function init_operations() {\n\tif (node_prototype !== undefined) {\n\t\treturn;\n\t}\n\n\tnode_prototype = Node.prototype;\n\telement_prototype = Element.prototype;\n\ttext_prototype = Text.prototype;\n\n\tappend_child_method = node_prototype.appendChild;\n\tclone_node_method = node_prototype.cloneNode;\n\n\t$window = window;\n\t$document = document;\n\n\t// the following assignments improve perf of lookups on DOM nodes\n\t// @ts-expect-error\n\telement_prototype.__click = undefined;\n\t// @ts-expect-error\n\ttext_prototype.__nodeValue = ' ';\n\t// @ts-expect-error\n\telement_prototype.__className = '';\n\n\tfirst_child_get = /** @type {(this: Node) => ChildNode | null} */ (\n\t\t// @ts-ignore\n\t\tget_descriptor(node_prototype, 'firstChild').get\n\t);\n\n\tnext_sibling_get = /** @type {(this: Node) => ChildNode | null} */ (\n\t\t// @ts-ignore\n\t\tget_descriptor(node_prototype, 'nextSibling').get\n\t);\n\n\ttext_content_set = /** @type {(this: Node, text: string ) => void} */ (\n\t\t// @ts-ignore\n\t\tget_descriptor(node_prototype, 'textContent').set\n\t);\n\n\tclass_name_set = /** @type {(this: Element, class_name: string) => void} */ (\n\t\t// @ts-ignore\n\t\tget_descriptor(element_prototype, 'className').set\n\t);\n}\n\n/**\n * @template {Element} E\n * @template {Node} T\n * @param {E} element\n * @param {T} child\n */\nexport function append_child(element, child) {\n\tappend_child_method.call(element, child);\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @param {boolean} deep\n * @returns {N}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function clone_node(node, deep) {\n\treturn /** @type {N} */ (clone_node_method.call(node, deep));\n}\n\n/** @returns {Text} */\nexport function empty() {\n\treturn document.createTextNode('');\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @returns {Node | null}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function child(node) {\n\tconst child = first_child_get.call(node);\n\tif (hydrating) {\n\t\t// Child can be null if we have an element with a single child, like `<p>{text}</p>`, where `text` is empty\n\t\tif (child === null) {\n\t\t\tconst text = empty();\n\t\t\tnode.appendChild(text);\n\t\t\treturn text;\n\t\t} else {\n\t\t\treturn capture_fragment_from_node(child);\n\t\t}\n\t}\n\treturn child;\n}\n\n/**\n * @template {Node | Node[]} N\n * @param {N} node\n * @param {boolean} is_text\n * @returns {Node | null}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function child_frag(node, is_text) {\n\tif (hydrating) {\n\t\tconst first_node = /** @type {Node[]} */ (node)[0];\n\n\t\t// if an {expression} is empty during SSR, there might be no\n\t\t// text node to hydrate â€” we must therefore create one\n\t\tif (is_text && first_node?.nodeType !== 3) {\n\t\t\tconst text = empty();\n\t\t\tcurrent_hydration_fragment.unshift(text);\n\t\t\tif (first_node) {\n\t\t\t\t/** @type {DocumentFragment} */ (first_node.parentNode).insertBefore(text, first_node);\n\t\t\t}\n\t\t\treturn text;\n\t\t}\n\n\t\tif (first_node !== null) {\n\t\t\treturn capture_fragment_from_node(first_node);\n\t\t}\n\n\t\treturn first_node;\n\t}\n\n\treturn first_child_get.call(/** @type {Node} */ (node));\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @param {boolean} is_text\n * @returns {Node | null}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function sibling(node, is_text = false) {\n\tconst next_sibling = next_sibling_get.call(node);\n\tif (hydrating) {\n\t\t// if a sibling {expression} is empty during SSR, there might be no\n\t\t// text node to hydrate â€” we must therefore create one\n\t\tif (is_text && next_sibling?.nodeType !== 3) {\n\t\t\tconst text = empty();\n\t\t\tif (next_sibling) {\n\t\t\t\tconst index = current_hydration_fragment.indexOf(\n\t\t\t\t\t/** @type {Text | Comment | Element} */ (next_sibling)\n\t\t\t\t);\n\t\t\t\tcurrent_hydration_fragment.splice(index, 0, text);\n\t\t\t\t/** @type {DocumentFragment} */ (next_sibling.parentNode).insertBefore(text, next_sibling);\n\t\t\t} else {\n\t\t\t\tcurrent_hydration_fragment.push(text);\n\t\t\t}\n\n\t\t\treturn text;\n\t\t}\n\n\t\tif (next_sibling !== null) {\n\t\t\treturn capture_fragment_from_node(next_sibling);\n\t\t}\n\t}\n\treturn next_sibling;\n}\n\n/**\n * @template {Element} N\n * @param {N} node\n * @param {string} class_name\n * @returns {void}\n */\nexport function set_class_name(node, class_name) {\n\tclass_name_set.call(node, class_name);\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @returns {void}\n */\nexport function clear_text_content(node) {\n\ttext_content_set.call(node, '');\n}\n\n/** @param {string} name */\n/*#__NO_SIDE_EFFECTS__*/\nexport function create_element(name) {\n\treturn document.createElement(name);\n}\n\n/**\n * Expects to only be called in hydration mode\n * @param {Node} node\n * @returns {Node}\n */\nfunction capture_fragment_from_node(node) {\n\tif (\n\t\tnode.nodeType === 8 &&\n\t\t/** @type {Comment} */ (node).data.startsWith('ssr:') &&\n\t\tcurrent_hydration_fragment[current_hydration_fragment.length - 1] !== node\n\t) {\n\t\tconst fragment = /** @type {Array<Element | Text | Comment>} */ (get_hydration_fragment(node));\n\t\tconst last_child = fragment[fragment.length - 1] || node;\n\t\tconst target = /** @type {Node} */ (last_child.nextSibling);\n\t\t// @ts-ignore\n\t\ttarget.$$fragment = fragment;\n\t\treturn target;\n\t}\n\treturn node;\n}\n","import { append_child } from './operations.js';\nimport { current_hydration_fragment, hydrate_block_anchor, hydrating } from './hydration.js';\nimport { is_array } from '../utils.js';\n\n/** @param {string} html */\nexport function create_fragment_from_html(html) {\n\tvar elem = document.createElement('template');\n\telem.innerHTML = html;\n\treturn elem.content;\n}\n\n/**\n * Creating a document fragment from HTML that contains script tags will not execute\n * the scripts. We need to replace the script tags with new ones so that they are executed.\n * @param {string} html\n */\nexport function create_fragment_with_script_from_html(html) {\n\tvar content = create_fragment_from_html(html);\n\tvar scripts = content.querySelectorAll('script');\n\tfor (const script of scripts) {\n\t\tvar new_script = document.createElement('script');\n\t\tfor (var i = 0; i < script.attributes.length; i++) {\n\t\t\tnew_script.setAttribute(script.attributes[i].name, script.attributes[i].value);\n\t\t}\n\t\tnew_script.textContent = script.textContent;\n\t\t/** @type {Node} */ (script.parentNode).replaceChild(new_script, script);\n\t}\n\treturn content;\n}\n\n/**\n * @param {Array<import('../types.js').TemplateNode> | import('../types.js').TemplateNode} current\n * @param {null | Element} parent_element\n * @param {null | Text | Element | Comment} sibling\n * @returns {Text | Element | Comment}\n */\nexport function insert(current, parent_element, sibling) {\n\tif (is_array(current)) {\n\t\tvar i = 0;\n\t\tvar node;\n\t\tfor (; i < current.length; i++) {\n\t\t\tnode = current[i];\n\t\t\tif (sibling === null) {\n\t\t\t\tappend_child(/** @type {Element} */ (parent_element), /** @type {Node} */ (node));\n\t\t\t} else {\n\t\t\t\tsibling.before(/** @type {Node} */ (node));\n\t\t\t}\n\t\t}\n\t\treturn current[0];\n\t} else if (current !== null) {\n\t\tif (sibling === null) {\n\t\t\tappend_child(/** @type {Element} */ (parent_element), /** @type {Node} */ (current));\n\t\t} else {\n\t\t\tsibling.before(/** @type {Node} */ (current));\n\t\t}\n\t}\n\treturn /** @type {Text | Element | Comment} */ (current);\n}\n\n/**\n * @param {Array<import('../types.js').TemplateNode> | import('../types.js').TemplateNode} current\n * @returns {Element | Comment | Text}\n */\nexport function remove(current) {\n\tvar first_node = current;\n\tif (is_array(current)) {\n\t\tvar i = 0;\n\t\tvar node;\n\t\tfor (; i < current.length; i++) {\n\t\t\tnode = current[i];\n\t\t\tif (i === 0) {\n\t\t\t\tfirst_node = node;\n\t\t\t}\n\t\t\tif (node.isConnected) {\n\t\t\t\tnode.remove();\n\t\t\t}\n\t\t}\n\t} else if (current.isConnected) {\n\t\tcurrent.remove();\n\t}\n\treturn /** @type {Element | Comment | Text} */ (first_node);\n}\n\n/**\n * Creates the content for a `@html` tag from its string value,\n * inserts it before the target anchor and returns the new nodes.\n * @template V\n * @param {Element | Text | Comment} target\n * @param {V} value\n * @param {boolean} svg\n * @returns {Element | Comment | (Element | Comment | Text)[]}\n */\nexport function reconcile_html(target, value, svg) {\n\thydrate_block_anchor(target);\n\tif (hydrating) {\n\t\treturn current_hydration_fragment;\n\t}\n\tvar html = value + '';\n\t// Even if html is the empty string we need to continue to insert something or\n\t// else the element ordering gets out of sync, resulting in subsequent values\n\t// not getting inserted anymore.\n\tvar frag_nodes;\n\tif (svg) {\n\t\thtml = `<svg>${html}</svg>`;\n\t}\n\t// Don't use create_fragment_with_script_from_html here because that would mean script tags are executed.\n\t// @html is basically `.innerHTML = ...` and that doesn't execute scripts either due to security reasons.\n\tvar content = create_fragment_from_html(html);\n\tif (svg) {\n\t\tcontent = /** @type {DocumentFragment} */ (/** @type {unknown} */ (content.firstChild));\n\t}\n\tvar clone = content.cloneNode(true);\n\tfrag_nodes = Array.from(clone.childNodes);\n\tfrag_nodes.forEach((node) => {\n\t\ttarget.before(node);\n\t});\n\treturn /** @type {Array<Text | Comment | Element>} */ (frag_nodes);\n}\n","export const EACH_ITEM_REACTIVE = 1;\nexport const EACH_INDEX_REACTIVE = 1 << 1;\nexport const EACH_KEYED = 1 << 2;\n\n/** See EachBlock interface metadata.is_controlled for an explanation what this is */\nexport const EACH_IS_CONTROLLED = 1 << 3;\nexport const EACH_IS_ANIMATED = 1 << 4;\nexport const EACH_IS_STRICT_EQUALS = 1 << 6;\n\nexport const PROPS_IS_IMMUTABLE = 1;\nexport const PROPS_IS_RUNES = 1 << 1;\nexport const PROPS_IS_UPDATED = 1 << 2;\nexport const PROPS_IS_LAZY_INITIAL = 1 << 3;\n\n/** List of Element events that will be delegated */\nexport const DelegatedEvents = [\n\t'beforeinput',\n\t'click',\n\t'dblclick',\n\t'contextmenu',\n\t'focusin',\n\t'focusout',\n\t// 'input', This conflicts with bind:input\n\t'keydown',\n\t'keyup',\n\t'mousedown',\n\t'mousemove',\n\t'mouseout',\n\t'mouseover',\n\t'mouseup',\n\t'pointerdown',\n\t'pointermove',\n\t'pointerout',\n\t'pointerover',\n\t'pointerup',\n\t'touchend',\n\t'touchmove',\n\t'touchstart'\n];\n\n/** List of Element events that will be delegated and are passive */\nexport const PassiveDelegatedEvents = ['touchstart', 'touchmove', 'touchend'];\n\n/**\n * @type {Record<string, string>}\n * List of attribute names that should be aliased to their property names\n * because they behave differently between setting them as an attribute and\n * setting them as a property.\n */\nexport const AttributeAliases = {\n\t// no `class: 'className'` because we handle that separately\n\tformnovalidate: 'formNoValidate',\n\tismap: 'isMap',\n\tnomodule: 'noModule',\n\tplaysinline: 'playsInline',\n\treadonly: 'readOnly'\n};\n\n/**\n * Attributes that are boolean, i.e. they are present or not present.\n */\nexport const DOMBooleanAttributes = [\n\t'allowfullscreen',\n\t'async',\n\t'autofocus',\n\t'autoplay',\n\t'checked',\n\t'controls',\n\t'default',\n\t'disabled',\n\t'formnovalidate',\n\t'hidden',\n\t'indeterminate',\n\t'ismap',\n\t'loop',\n\t'multiple',\n\t'muted',\n\t'nomodule',\n\t'novalidate',\n\t'open',\n\t'playsinline',\n\t'readonly',\n\t'required',\n\t'reversed',\n\t'seamless',\n\t'selected'\n];\n\nexport const namespace_svg = 'http://www.w3.org/2000/svg';\nexport const namespace_html = 'http://www.w3.org/1999/xhtml';\n\n// while `input` is also an interactive element, it is never moved by the browser, so we don't need to check for it\nexport const interactive_elements = new Set([\n\t'a',\n\t'button',\n\t'iframe',\n\t'embed',\n\t'select',\n\t'textarea'\n]);\n\nexport const disallowed_paragraph_contents = [\n\t'address',\n\t'article',\n\t'aside',\n\t'blockquote',\n\t'details',\n\t'div',\n\t'dl',\n\t'fieldset',\n\t'figcapture',\n\t'figure',\n\t'footer',\n\t'form',\n\t'h1',\n\t'h2',\n\t'h3',\n\t'h4',\n\t'h5',\n\t'h6',\n\t'header',\n\t'hr',\n\t'menu',\n\t'nav',\n\t'ol',\n\t'pre',\n\t'section',\n\t'table',\n\t'ul'\n];\n\n// https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags\nconst implied_end_tags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];\n\n/**\n * @param {string} tag\n * @param {string} parent_tag\n * @returns {boolean}\n */\nexport function is_tag_valid_with_parent(tag, parent_tag) {\n\t// First, let's check if we're in an unusual parsing mode...\n\tswitch (parent_tag) {\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect\n\t\tcase 'select':\n\t\t\treturn tag === 'option' || tag === 'optgroup' || tag === '#text';\n\t\tcase 'optgroup':\n\t\t\treturn tag === 'option' || tag === '#text';\n\t\t// Strictly speaking, seeing an <option> doesn't mean we're in a <select>\n\t\t// but\n\t\tcase 'option':\n\t\t\treturn tag === '#text';\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption\n\t\t// No special behavior since these rules fall back to \"in body\" mode for\n\t\t// all except special table nodes which cause bad parsing behavior anyway.\n\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr\n\t\tcase 'tr':\n\t\t\treturn (\n\t\t\t\ttag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template'\n\t\t\t);\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody\n\t\tcase 'tbody':\n\t\tcase 'thead':\n\t\tcase 'tfoot':\n\t\t\treturn tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup\n\t\tcase 'colgroup':\n\t\t\treturn tag === 'col' || tag === 'template';\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable\n\t\tcase 'table':\n\t\t\treturn (\n\t\t\t\ttag === 'caption' ||\n\t\t\t\ttag === 'colgroup' ||\n\t\t\t\ttag === 'tbody' ||\n\t\t\t\ttag === 'tfoot' ||\n\t\t\t\ttag === 'thead' ||\n\t\t\t\ttag === 'style' ||\n\t\t\t\ttag === 'script' ||\n\t\t\t\ttag === 'template'\n\t\t\t);\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead\n\t\tcase 'head':\n\t\t\treturn (\n\t\t\t\ttag === 'base' ||\n\t\t\t\ttag === 'basefont' ||\n\t\t\t\ttag === 'bgsound' ||\n\t\t\t\ttag === 'link' ||\n\t\t\t\ttag === 'meta' ||\n\t\t\t\ttag === 'title' ||\n\t\t\t\ttag === 'noscript' ||\n\t\t\t\ttag === 'noframes' ||\n\t\t\t\ttag === 'style' ||\n\t\t\t\ttag === 'script' ||\n\t\t\t\ttag === 'template'\n\t\t\t);\n\t\t// https://html.spec.whatwg.org/multipage/semantics.html#the-html-element\n\t\tcase 'html':\n\t\t\treturn tag === 'head' || tag === 'body' || tag === 'frameset';\n\t\tcase 'frameset':\n\t\t\treturn tag === 'frame';\n\t\tcase '#document':\n\t\t\treturn tag === 'html';\n\t}\n\n\t// Probably in the \"in body\" parsing mode, so we outlaw only tag combos\n\t// where the parsing rules cause implicit opens or closes to be added.\n\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n\tswitch (tag) {\n\t\tcase 'h1':\n\t\tcase 'h2':\n\t\tcase 'h3':\n\t\tcase 'h4':\n\t\tcase 'h5':\n\t\tcase 'h6':\n\t\t\treturn (\n\t\t\t\tparent_tag !== 'h1' &&\n\t\t\t\tparent_tag !== 'h2' &&\n\t\t\t\tparent_tag !== 'h3' &&\n\t\t\t\tparent_tag !== 'h4' &&\n\t\t\t\tparent_tag !== 'h5' &&\n\t\t\t\tparent_tag !== 'h6'\n\t\t\t);\n\n\t\tcase 'rp':\n\t\tcase 'rt':\n\t\t\treturn implied_end_tags.indexOf(parent_tag) === -1;\n\n\t\tcase 'body':\n\t\tcase 'caption':\n\t\tcase 'col':\n\t\tcase 'colgroup':\n\t\tcase 'frameset':\n\t\tcase 'frame':\n\t\tcase 'head':\n\t\tcase 'html':\n\t\tcase 'tbody':\n\t\tcase 'td':\n\t\tcase 'tfoot':\n\t\tcase 'th':\n\t\tcase 'thead':\n\t\tcase 'tr':\n\t\t\t// These tags are only valid with a few parents that have special child\n\t\t\t// parsing rules -- if we're down here, then none of those matched and\n\t\t\t// so we allow it only if we don't know what the parent is, as all other\n\t\t\t// cases are invalid.\n\t\t\treturn parent_tag == null;\n\t}\n\n\treturn true;\n}\n","import {\n\tEACH_INDEX_REACTIVE,\n\tEACH_IS_ANIMATED,\n\tEACH_IS_CONTROLLED,\n\tEACH_IS_STRICT_EQUALS,\n\tEACH_ITEM_REACTIVE,\n\tEACH_KEYED\n} from '../../../../constants.js';\nimport { noop } from '../../../common.js';\nimport {\n\tcurrent_hydration_fragment,\n\tget_hydration_fragment,\n\thydrate_block_anchor,\n\thydrating,\n\tset_current_hydration_fragment\n} from '../hydration.js';\nimport { clear_text_content, empty } from '../operations.js';\nimport { insert, remove } from '../reconciler.js';\nimport { current_block, execute_effect } from '../../runtime.js';\nimport { destroy_effect, render_effect } from '../../reactivity/effects.js';\nimport { source, mutable_source, set } from '../../reactivity/sources.js';\nimport { trigger_transitions } from '../elements/transitions.js';\nimport { is_array, is_frozen, map_get, map_set } from '../../utils.js';\nimport { EACH_BLOCK, EACH_ITEM_BLOCK, STATE_SYMBOL } from '../../constants.js';\n\nconst NEW_BLOCK = -1;\nconst MOVED_BLOCK = 99999999;\nconst LIS_BLOCK = -2;\n\n/**\n * @param {number} flags\n * @param {Element | Comment} anchor\n * @returns {import('../../types.js').EachBlock}\n */\nexport function create_each_block(flags, anchor) {\n\treturn {\n\t\t// anchor\n\t\ta: anchor,\n\t\t// dom\n\t\td: null,\n\t\t// flags\n\t\tf: flags,\n\t\t// items\n\t\tv: [],\n\t\t// effect\n\t\te: null,\n\t\tp: /** @type {import('../../types.js').Block} */ (current_block),\n\t\t// transition\n\t\tr: null,\n\t\t// transitions\n\t\ts: [],\n\t\t// type\n\t\tt: EACH_BLOCK\n\t};\n}\n\n/**\n * @param {any | import('../../types.js').Value<any>} item\n * @param {number | import('../../types.js').Value<number>} index\n * @param {null | unknown} key\n * @returns {import('../../types.js').EachItemBlock}\n */\nexport function create_each_item_block(item, index, key) {\n\treturn {\n\t\t// animate transition\n\t\ta: null,\n\t\t// dom\n\t\td: null,\n\t\t// effect\n\t\te: null,\n\t\t// index\n\t\ti: index,\n\t\t// key\n\t\tk: key,\n\t\t// item\n\t\tv: item,\n\t\t// parent\n\t\tp: /** @type {import('../../types.js').EachBlock} */ (current_block),\n\t\t// transition\n\t\tr: null,\n\t\t// transitions\n\t\ts: null,\n\t\t// type\n\t\tt: EACH_ITEM_BLOCK\n\t};\n}\n\n/**\n * @template V\n * @param {Element | Comment} anchor_node\n * @param {() => V[]} collection\n * @param {number} flags\n * @param {null | ((item: V) => string)} key_fn\n * @param {(anchor: null, item: V, index: import('#client').MaybeSource<number>) => void} render_fn\n * @param {null | ((anchor: Node) => void)} fallback_fn\n * @param {typeof reconcile_indexed_array | reconcile_tracked_array} reconcile_fn\n * @returns {void}\n */\nfunction each(anchor_node, collection, flags, key_fn, render_fn, fallback_fn, reconcile_fn) {\n\tconst is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;\n\tconst block = create_each_block(flags, anchor_node);\n\n\t/** @type {null | import('../../types.js').Render} */\n\tlet current_fallback = null;\n\thydrate_block_anchor(anchor_node, is_controlled);\n\n\t/** @type {V[]} */\n\tlet array;\n\n\t/** @type {Array<string> | null} */\n\tlet keys = null;\n\n\t/** @type {null | import('../../types.js').Effect} */\n\tlet render = null;\n\n\t/**\n\t * Whether or not there was a \"rendered fallback but want to render items\" (or vice versa) hydration mismatch.\n\t * Needs to be a `let` or else it isn't treeshaken out\n\t */\n\tlet mismatch = false;\n\n\tblock.r =\n\t\t/** @param {import('../../types.js').Transition} transition */\n\t\t(transition) => {\n\t\t\tconst fallback = /** @type {import('../../types.js').Render} */ (current_fallback);\n\t\t\tconst transitions = fallback.s;\n\t\t\ttransitions.add(transition);\n\t\t\ttransition.f(() => {\n\t\t\t\ttransitions.delete(transition);\n\t\t\t\tif (transitions.size === 0) {\n\t\t\t\t\tif (fallback.e !== null) {\n\t\t\t\t\t\tif (fallback.d !== null) {\n\t\t\t\t\t\t\tremove(fallback.d);\n\t\t\t\t\t\t\tfallback.d = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdestroy_effect(fallback.e);\n\t\t\t\t\t\tfallback.e = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\tconst create_fallback_effect = () => {\n\t\t/** @type {import('../../types.js').Render} */\n\t\tconst fallback = {\n\t\t\td: null,\n\t\t\te: null,\n\t\t\ts: new Set(),\n\t\t\tp: current_fallback\n\t\t};\n\t\t// Managed effect\n\t\tconst effect = render_effect(\n\t\t\t() => {\n\t\t\t\tconst dom = block.d;\n\t\t\t\tif (dom !== null) {\n\t\t\t\t\tremove(dom);\n\t\t\t\t\tblock.d = null;\n\t\t\t\t}\n\t\t\t\tlet anchor = block.a;\n\t\t\t\tconst is_controlled = (block.f & EACH_IS_CONTROLLED) !== 0;\n\t\t\t\tif (is_controlled) {\n\t\t\t\t\t// If the each block is controlled, then the anchor node will be the surrounding\n\t\t\t\t\t// element in which the each block is rendered, which requires certain handling\n\t\t\t\t\t// depending on whether we're in hydration mode or not\n\t\t\t\t\tif (!hydrating) {\n\t\t\t\t\t\t// Create a new anchor on the fly because there's none due to the optimization\n\t\t\t\t\t\tanchor = empty();\n\t\t\t\t\t\tblock.a.appendChild(anchor);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// In case of hydration the anchor will be the first child of the surrounding element\n\t\t\t\t\t\tanchor = /** @type {Comment} */ (anchor.firstChild);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/** @type {(anchor: Node) => void} */ (fallback_fn)(anchor);\n\t\t\t\tfallback.d = block.d;\n\t\t\t\tblock.d = null;\n\t\t\t},\n\t\t\tblock,\n\t\t\ttrue\n\t\t);\n\t\tfallback.e = effect;\n\t\tcurrent_fallback = fallback;\n\t};\n\n\t/** @param {import('../../types.js').EachBlock} block */\n\tconst render_each = (block) => {\n\t\tconst flags = block.f;\n\t\tconst is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;\n\t\tconst anchor_node = block.a;\n\t\treconcile_fn(array, block, anchor_node, is_controlled, render_fn, flags, true, keys);\n\t};\n\n\tconst each = render_effect(\n\t\t() => {\n\t\t\t/** @type {V[]} */\n\t\t\tconst maybe_array = collection();\n\t\t\tarray = is_array(maybe_array)\n\t\t\t\t? maybe_array\n\t\t\t\t: maybe_array == null\n\t\t\t\t\t? []\n\t\t\t\t\t: Array.from(maybe_array);\n\n\t\t\tif (key_fn !== null) {\n\t\t\t\tkeys = array.map(key_fn);\n\t\t\t} else if ((flags & EACH_KEYED) === 0) {\n\t\t\t\tarray.map(noop);\n\t\t\t}\n\n\t\t\tconst length = array.length;\n\n\t\t\tif (hydrating) {\n\t\t\t\tconst is_each_else_comment =\n\t\t\t\t\t/** @type {Comment} */ (current_hydration_fragment?.[0])?.data === 'ssr:each_else';\n\t\t\t\t// Check for hydration mismatch which can happen if the server renders the each fallback\n\t\t\t\t// but the client has items, or vice versa. If so, remove everything inside the anchor and start fresh.\n\t\t\t\tif ((is_each_else_comment && length) || (!is_each_else_comment && !length)) {\n\t\t\t\t\tremove(current_hydration_fragment);\n\t\t\t\t\tset_current_hydration_fragment(null);\n\t\t\t\t\tmismatch = true;\n\t\t\t\t} else if (is_each_else_comment) {\n\t\t\t\t\t// Remove the each_else comment node or else it will confuse the subsequent hydration algorithm\n\t\t\t\t\t/** @type {import('../../types.js').TemplateNode[]} */ (\n\t\t\t\t\t\tcurrent_hydration_fragment\n\t\t\t\t\t).shift();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (fallback_fn !== null) {\n\t\t\t\tif (length === 0) {\n\t\t\t\t\tif (block.v.length !== 0 || render === null) {\n\t\t\t\t\t\trender_each(block);\n\t\t\t\t\t\tcreate_fallback_effect();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else if (block.v.length === 0 && current_fallback !== null) {\n\t\t\t\t\tconst fallback = current_fallback;\n\t\t\t\t\tconst transitions = fallback.s;\n\t\t\t\t\tif (transitions.size === 0) {\n\t\t\t\t\t\tif (fallback.d !== null) {\n\t\t\t\t\t\t\tremove(fallback.d);\n\t\t\t\t\t\t\tfallback.d = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttrigger_transitions(transitions, 'out');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (render !== null) {\n\t\t\t\texecute_effect(render);\n\t\t\t}\n\t\t},\n\t\tblock,\n\t\tfalse\n\t);\n\n\trender = render_effect(render_each, block, true);\n\n\tif (mismatch) {\n\t\t// Set a fragment so that Svelte continues to operate in hydration mode\n\t\tset_current_hydration_fragment([]);\n\t}\n\n\teach.ondestroy = () => {\n\t\tconst flags = block.f;\n\t\tconst anchor_node = block.a;\n\t\tconst is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;\n\t\tlet fallback = current_fallback;\n\t\twhile (fallback !== null) {\n\t\t\tconst dom = fallback.d;\n\t\t\tif (dom !== null) {\n\t\t\t\tremove(dom);\n\t\t\t}\n\t\t\tconst effect = fallback.e;\n\t\t\tif (effect !== null) {\n\t\t\t\tdestroy_effect(effect);\n\t\t\t}\n\t\t\tfallback = fallback.p;\n\t\t}\n\t\t// Clear the array\n\t\treconcile_fn([], block, anchor_node, is_controlled, render_fn, flags, false, keys);\n\t\tdestroy_effect(/** @type {import('#client').Effect} */ (render));\n\t};\n\n\tblock.e = each;\n}\n\n/**\n * @template V\n * @param {Element | Comment} anchor_node\n * @param {() => V[]} collection\n * @param {number} flags\n * @param {null | ((item: V) => string)} key_fn\n * @param {(anchor: null, item: V, index: import('#client').MaybeSource<number>) => void} render_fn\n * @param {null | ((anchor: Node) => void)} fallback_fn\n * @returns {void}\n */\nexport function each_keyed(anchor_node, collection, flags, key_fn, render_fn, fallback_fn) {\n\teach(anchor_node, collection, flags, key_fn, render_fn, fallback_fn, reconcile_tracked_array);\n}\n\n/**\n * @template V\n * @param {Element | Comment} anchor_node\n * @param {() => V[]} collection\n * @param {number} flags\n * @param {(anchor: null, item: V, index: import('#client').MaybeSource<number>) => void} render_fn\n * @param {null | ((anchor: Node) => void)} fallback_fn\n * @returns {void}\n */\nexport function each_indexed(anchor_node, collection, flags, render_fn, fallback_fn) {\n\teach(anchor_node, collection, flags, null, render_fn, fallback_fn, reconcile_indexed_array);\n}\n\n/**\n * @template V\n * @param {Array<V>} array\n * @param {import('../../types.js').EachBlock} each_block\n * @param {Element | Comment | Text} dom\n * @param {boolean} is_controlled\n * @param {(anchor: null, item: V, index: number | import('../../types.js').Source<number>) => void} render_fn\n * @param {number} flags\n * @param {boolean} apply_transitions\n * @returns {void}\n */\nfunction reconcile_indexed_array(\n\tarray,\n\teach_block,\n\tdom,\n\tis_controlled,\n\trender_fn,\n\tflags,\n\tapply_transitions\n) {\n\t// If we are working with an array that isn't proxied or frozen, then remove strict equality and ensure the items\n\t// are treated as reactive, so they get wrapped in a signal.\n\tif ((flags & EACH_IS_STRICT_EQUALS) !== 0 && !is_frozen(array) && !(STATE_SYMBOL in array)) {\n\t\tflags ^= EACH_IS_STRICT_EQUALS;\n\t}\n\tvar a_blocks = each_block.v;\n\tvar active_transitions = each_block.s;\n\n\t/** @type {number | void} */\n\tvar a = a_blocks.length;\n\n\t/** @type {number} */\n\tvar b = array.length;\n\tvar length = Math.max(a, b);\n\tvar index = 0;\n\n\t/** @type {Array<import('../../types.js').EachItemBlock>} */\n\tvar b_blocks;\n\tvar block;\n\n\tif (active_transitions.length !== 0) {\n\t\tdestroy_active_transition_blocks(active_transitions);\n\t}\n\n\tif (b === 0) {\n\t\tb_blocks = [];\n\t\t// Remove old blocks\n\t\tif (is_controlled && a !== 0) {\n\t\t\tclear_text_content(dom);\n\t\t}\n\t\twhile (index < length) {\n\t\t\tblock = a_blocks[index++];\n\t\t\tdestroy_each_item_block(block, active_transitions, apply_transitions, is_controlled);\n\t\t}\n\t} else {\n\t\tvar item;\n\t\t/** `true` if there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\t\tb_blocks = Array(b);\n\t\tif (hydrating) {\n\t\t\t// Hydrate block\n\t\t\tvar hydration_list = /** @type {import('../../types.js').TemplateNode[]} */ (\n\t\t\t\tcurrent_hydration_fragment\n\t\t\t);\n\t\t\tvar hydrating_node = hydration_list[0];\n\t\t\tfor (; index < length; index++) {\n\t\t\t\tvar fragment = get_hydration_fragment(hydrating_node);\n\t\t\t\tset_current_hydration_fragment(fragment);\n\t\t\t\tif (!fragment) {\n\t\t\t\t\t// If fragment is null, then that means that the server rendered less items than what\n\t\t\t\t\t// the client code specifies -> break out and continue with client-side node creation\n\t\t\t\t\tmismatch = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\titem = array[index];\n\t\t\t\tblock = each_item_block(item, null, index, render_fn, flags);\n\t\t\t\tb_blocks[index] = block;\n\n\t\t\t\thydrating_node = /** @type {import('../../types.js').TemplateNode} */ (\n\t\t\t\t\t/** @type {Node} */ (/** @type {Node} */ (fragment[fragment.length - 1]).nextSibling)\n\t\t\t\t\t\t.nextSibling\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tremove_excess_hydration_nodes(hydration_list, hydrating_node);\n\t\t}\n\n\t\tfor (; index < length; index++) {\n\t\t\tif (index >= a) {\n\t\t\t\t// Add block\n\t\t\t\titem = array[index];\n\t\t\t\tblock = each_item_block(item, null, index, render_fn, flags);\n\t\t\t\tb_blocks[index] = block;\n\t\t\t\tinsert_each_item_block(block, dom, is_controlled, null);\n\t\t\t} else if (index >= b) {\n\t\t\t\t// Remove block\n\t\t\t\tblock = a_blocks[index];\n\t\t\t\tdestroy_each_item_block(block, active_transitions, apply_transitions);\n\t\t\t} else {\n\t\t\t\t// Update block\n\t\t\t\titem = array[index];\n\t\t\t\tblock = a_blocks[index];\n\t\t\t\tb_blocks[index] = block;\n\t\t\t\tupdate_each_item_block(block, item, index, flags);\n\t\t\t}\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// Server rendered less nodes than the client -> set empty array so that Svelte continues to operate in hydration mode\n\t\t\tset_current_hydration_fragment([]);\n\t\t}\n\t}\n\n\teach_block.v = b_blocks;\n}\n\n/**\n * Reconcile arrays by the equality of the elements in the array. This algorithm\n * is based on Ivi's reconcilation logic:\n * https://github.com/localvoid/ivi/blob/9f1bd0918f487da5b131941228604763c5d8ef56/packages/ivi/src/client/core.ts#L968\n * @template V\n * @param {Array<V>} array\n * @param {import('../../types.js').EachBlock} each_block\n * @param {Element | Comment | Text} dom\n * @param {boolean} is_controlled\n * @param {(anchor: null, item: V, index: number | import('../../types.js').Source<number>) => void} render_fn\n * @param {number} flags\n * @param {boolean} apply_transitions\n * @param {Array<string> | null} keys\n * @returns {void}\n */\nfunction reconcile_tracked_array(\n\tarray,\n\teach_block,\n\tdom,\n\tis_controlled,\n\trender_fn,\n\tflags,\n\tapply_transitions,\n\tkeys\n) {\n\t// If we are working with an array that isn't proxied or frozen, then remove strict equality and ensure the items\n\t// are treated as reactive, so they get wrapped in a signal.\n\tif ((flags & EACH_IS_STRICT_EQUALS) !== 0 && !is_frozen(array) && !(STATE_SYMBOL in array)) {\n\t\tflags ^= EACH_IS_STRICT_EQUALS;\n\t\t// Additionally as we're in an keyed each block, we'll need ensure the itens are all wrapped in signals.\n\t\tif ((flags & EACH_ITEM_REACTIVE) === 0) {\n\t\t\tflags ^= EACH_ITEM_REACTIVE;\n\t\t}\n\t}\n\tvar a_blocks = each_block.v;\n\tconst is_computed_key = keys !== null;\n\tvar active_transitions = each_block.s;\n\n\t/** @type {number | void} */\n\tvar a = a_blocks.length;\n\n\t/** @type {number} */\n\tvar b = array.length;\n\n\t/** @type {Array<import('../../types.js').EachItemBlock>} */\n\tvar b_blocks;\n\tvar block;\n\n\tif (active_transitions.length !== 0) {\n\t\tdestroy_active_transition_blocks(active_transitions);\n\t}\n\n\tif (b === 0) {\n\t\tb_blocks = [];\n\t\t// Remove old blocks\n\t\tif (is_controlled && a !== 0) {\n\t\t\tclear_text_content(dom);\n\t\t}\n\t\twhile (a > 0) {\n\t\t\tblock = a_blocks[--a];\n\t\t\tdestroy_each_item_block(block, active_transitions, apply_transitions, is_controlled);\n\t\t}\n\t} else {\n\t\tvar a_end = a - 1;\n\t\tvar b_end = b - 1;\n\t\tvar key;\n\t\tvar item;\n\t\tvar idx;\n\t\t/** `true` if there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\t\tb_blocks = Array(b);\n\t\tif (hydrating) {\n\t\t\t// Hydrate block\n\t\t\tvar fragment;\n\t\t\tvar hydration_list = /** @type {import('../../types.js').TemplateNode[]} */ (\n\t\t\t\tcurrent_hydration_fragment\n\t\t\t);\n\t\t\tvar hydrating_node = hydration_list[0];\n\t\t\twhile (b > 0) {\n\t\t\t\tfragment = get_hydration_fragment(hydrating_node);\n\t\t\t\tset_current_hydration_fragment(fragment);\n\t\t\t\tif (!fragment) {\n\t\t\t\t\t// If fragment is null, then that means that the server rendered less items than what\n\t\t\t\t\t// the client code specifies -> break out and continue with client-side node creation\n\t\t\t\t\tmismatch = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tidx = b_end - --b;\n\t\t\t\titem = array[idx];\n\t\t\t\tkey = is_computed_key ? keys[idx] : item;\n\t\t\t\tblock = each_item_block(item, key, idx, render_fn, flags);\n\t\t\t\tb_blocks[idx] = block;\n\n\t\t\t\t// Get the <!--ssr:..--> tag of the next item in the list\n\t\t\t\t// The fragment array can be empty if each block has no content\n\t\t\t\thydrating_node = /** @type {import('../../types.js').TemplateNode} */ (\n\t\t\t\t\t/** @type {Node} */ ((fragment[fragment.length - 1] || hydrating_node).nextSibling)\n\t\t\t\t\t\t.nextSibling\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tremove_excess_hydration_nodes(hydration_list, hydrating_node);\n\t\t}\n\n\t\tif (a === 0) {\n\t\t\t// Create new blocks\n\t\t\twhile (b > 0) {\n\t\t\t\tidx = b_end - --b;\n\t\t\t\titem = array[idx];\n\t\t\t\tkey = is_computed_key ? keys[idx] : item;\n\t\t\t\tblock = each_item_block(item, key, idx, render_fn, flags);\n\t\t\t\tb_blocks[idx] = block;\n\t\t\t\tinsert_each_item_block(block, dom, is_controlled, null);\n\t\t\t}\n\t\t} else {\n\t\t\tvar is_animated = (flags & EACH_IS_ANIMATED) !== 0;\n\t\t\tvar should_update_block =\n\t\t\t\t(flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0 || is_animated;\n\t\t\tvar start = 0;\n\n\t\t\t/** @type {null | Text | Element | Comment} */\n\t\t\tvar sibling = null;\n\t\t\titem = array[b_end];\n\t\t\tkey = is_computed_key ? keys[b_end] : item;\n\t\t\t// Step 1\n\t\t\touter: while (true) {\n\t\t\t\t// From the end\n\t\t\t\twhile (a_blocks[a_end].k === key) {\n\t\t\t\t\tblock = a_blocks[a_end--];\n\t\t\t\t\titem = array[b_end];\n\t\t\t\t\tif (should_update_block) {\n\t\t\t\t\t\tupdate_each_item_block(block, item, b_end, flags);\n\t\t\t\t\t}\n\t\t\t\t\tsibling = get_first_child(block);\n\t\t\t\t\tb_blocks[b_end] = block;\n\t\t\t\t\tif (start > --b_end || start > a_end) {\n\t\t\t\t\t\tbreak outer;\n\t\t\t\t\t}\n\t\t\t\t\tkey = is_computed_key ? keys[b_end] : item;\n\t\t\t\t}\n\t\t\t\titem = array[start];\n\t\t\t\tkey = is_computed_key ? keys[start] : item;\n\t\t\t\t// At the start\n\t\t\t\twhile (start <= a_end && start <= b_end && a_blocks[start].k === key) {\n\t\t\t\t\titem = array[start];\n\t\t\t\t\tblock = a_blocks[start];\n\t\t\t\t\tif (should_update_block) {\n\t\t\t\t\t\tupdate_each_item_block(block, item, start, flags);\n\t\t\t\t\t}\n\t\t\t\t\tb_blocks[start] = block;\n\t\t\t\t\t++start;\n\t\t\t\t\tkey = is_computed_key ? keys[start] : array[start];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// Step 2\n\t\t\tif (start > a_end) {\n\t\t\t\twhile (b_end >= start) {\n\t\t\t\t\titem = array[b_end];\n\t\t\t\t\tkey = is_computed_key ? keys[b_end] : item;\n\t\t\t\t\tblock = each_item_block(item, key, b_end, render_fn, flags);\n\t\t\t\t\tb_blocks[b_end--] = block;\n\t\t\t\t\tsibling = insert_each_item_block(block, dom, is_controlled, sibling);\n\t\t\t\t}\n\t\t\t} else if (start > b_end) {\n\t\t\t\tb = start;\n\t\t\t\tdo {\n\t\t\t\t\tif ((block = a_blocks[b++]) !== null) {\n\t\t\t\t\t\tdestroy_each_item_block(block, active_transitions, apply_transitions);\n\t\t\t\t\t}\n\t\t\t\t} while (b <= a_end);\n\t\t\t} else {\n\t\t\t\t// Step 3\n\t\t\t\tvar pos = 0;\n\t\t\t\tvar b_length = b_end - start + 1;\n\t\t\t\tvar sources = new Int32Array(b_length);\n\t\t\t\tvar item_index = new Map();\n\t\t\t\tfor (b = 0; b < b_length; ++b) {\n\t\t\t\t\ta = b + start;\n\t\t\t\t\tsources[b] = NEW_BLOCK;\n\t\t\t\t\titem = array[a];\n\t\t\t\t\tkey = is_computed_key ? keys[a] : item;\n\t\t\t\t\tmap_set(item_index, key, a);\n\t\t\t\t}\n\t\t\t\t// If keys are animated, we need to do updates before actual moves\n\t\t\t\tif (is_animated) {\n\t\t\t\t\tfor (b = start; b <= a_end; ++b) {\n\t\t\t\t\t\ta = map_get(item_index, /** @type {V} */ (a_blocks[b].k));\n\t\t\t\t\t\tif (a !== undefined) {\n\t\t\t\t\t\t\titem = array[a];\n\t\t\t\t\t\t\tblock = a_blocks[b];\n\t\t\t\t\t\t\tupdate_each_item_block(block, item, a, flags);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (b = start; b <= a_end; ++b) {\n\t\t\t\t\ta = map_get(item_index, /** @type {V} */ (a_blocks[b].k));\n\t\t\t\t\tblock = a_blocks[b];\n\t\t\t\t\tif (a !== undefined) {\n\t\t\t\t\t\tpos = pos < a ? a : MOVED_BLOCK;\n\t\t\t\t\t\tsources[a - start] = b;\n\t\t\t\t\t\tb_blocks[a] = block;\n\t\t\t\t\t} else if (block !== null) {\n\t\t\t\t\t\tdestroy_each_item_block(block, active_transitions, apply_transitions);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Step 4\n\t\t\t\tif (pos === MOVED_BLOCK) {\n\t\t\t\t\tmark_lis(sources);\n\t\t\t\t}\n\t\t\t\tvar last_block;\n\t\t\t\tvar last_sibling;\n\t\t\t\tvar should_create;\n\t\t\t\twhile (b_length-- > 0) {\n\t\t\t\t\tb_end = b_length + start;\n\t\t\t\t\ta = sources[b_length];\n\t\t\t\t\tshould_create = a === -1;\n\t\t\t\t\titem = array[b_end];\n\t\t\t\t\tif (should_create) {\n\t\t\t\t\t\tkey = is_computed_key ? keys[b_end] : item;\n\t\t\t\t\t\tblock = each_item_block(item, key, b_end, render_fn, flags);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tblock = b_blocks[b_end];\n\t\t\t\t\t\tif (!is_animated && should_update_block) {\n\t\t\t\t\t\t\tupdate_each_item_block(block, item, b_end, flags);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (should_create || (pos === MOVED_BLOCK && a !== LIS_BLOCK)) {\n\t\t\t\t\t\tlast_sibling = last_block === undefined ? sibling : get_first_child(last_block);\n\t\t\t\t\t\tsibling = insert_each_item_block(block, dom, is_controlled, last_sibling);\n\t\t\t\t\t}\n\t\t\t\t\tb_blocks[b_end] = block;\n\t\t\t\t\tlast_block = block;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// Server rendered less nodes than the client -> set empty array so that Svelte continues to operate in hydration mode\n\t\t\tset_current_hydration_fragment([]);\n\t\t}\n\t}\n\n\teach_block.v = b_blocks;\n}\n\n/**\n * The server could have rendered more list items than the client specifies.\n * In that case, we need to remove the remaining server-rendered nodes.\n * @param {import('../../types.js').TemplateNode[]} hydration_list\n * @param {import('../../types.js').TemplateNode | null} next_node\n */\nfunction remove_excess_hydration_nodes(hydration_list, next_node) {\n\tif (next_node === null) return;\n\tvar idx = hydration_list.indexOf(next_node);\n\tif (idx !== -1 && hydration_list.length > idx + 1) {\n\t\tremove(hydration_list.slice(idx));\n\t}\n}\n\n/**\n * Longest Increased Subsequence algorithm\n * @param {Int32Array} a\n * @returns {void}\n */\nfunction mark_lis(a) {\n\tvar length = a.length;\n\tvar parent = new Int32Array(length);\n\tvar index = new Int32Array(length);\n\tvar index_length = 0;\n\tvar i = 0;\n\n\t/** @type {number} */\n\tvar j;\n\n\t/** @type {number} */\n\tvar k;\n\n\t/** @type {number} */\n\tvar lo;\n\n\t/** @type {number} */\n\tvar hi;\n\n\t// Skip -1 values at the start of the input array `a`.\n\tfor (; a[i] === NEW_BLOCK; ++i) {\n\t\t/**/\n\t}\n\n\tindex[0] = i++;\n\n\tfor (; i < length; ++i) {\n\t\tk = a[i];\n\n\t\tif (k !== NEW_BLOCK) {\n\t\t\t// Ignore -1 values.\n\t\t\tj = index[index_length];\n\n\t\t\tif (a[j] < k) {\n\t\t\t\tparent[i] = j;\n\t\t\t\tindex[++index_length] = i;\n\t\t\t} else {\n\t\t\t\tlo = 0;\n\t\t\t\thi = index_length;\n\n\t\t\t\twhile (lo < hi) {\n\t\t\t\t\tj = (lo + hi) >> 1;\n\t\t\t\t\tif (a[index[j]] < k) {\n\t\t\t\t\t\tlo = j + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\thi = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (k < a[index[lo]]) {\n\t\t\t\t\tif (lo > 0) {\n\t\t\t\t\t\tparent[i] = index[lo - 1];\n\t\t\t\t\t}\n\t\t\t\t\tindex[lo] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Mutate input array `a` and assign -2 value to all nodes that are part of LIS.\n\tj = index[index_length];\n\n\twhile (index_length-- >= 0) {\n\t\ta[j] = LIS_BLOCK;\n\t\tj = parent[j];\n\t}\n}\n\n/**\n * @param {import('../../types.js').Block} block\n * @param {Element | Comment | Text} dom\n * @param {boolean} is_controlled\n * @param {null | Text | Element | Comment} sibling\n * @returns {Text | Element | Comment}\n */\nfunction insert_each_item_block(block, dom, is_controlled, sibling) {\n\tvar current = /** @type {import('../../types.js').TemplateNode} */ (block.d);\n\n\tif (sibling === null) {\n\t\tif (is_controlled) {\n\t\t\treturn insert(current, /** @type {Element} */ (dom), null);\n\t\t} else {\n\t\t\treturn insert(current, /** @type {Element} */ (dom.parentNode), dom);\n\t\t}\n\t}\n\n\treturn insert(current, null, sibling);\n}\n\n/**\n * @param {import('../../types.js').Block} block\n * @returns {Text | Element | Comment}\n */\nfunction get_first_child(block) {\n\tvar current = block.d;\n\n\tif (is_array(current)) {\n\t\treturn /** @type {Text | Element | Comment} */ (current[0]);\n\t}\n\n\treturn /** @type {Text | Element | Comment} */ (current);\n}\n\n/**\n * @param {Array<import('../../types.js').EachItemBlock>} active_transitions\n * @returns {void}\n */\nfunction destroy_active_transition_blocks(active_transitions) {\n\tvar length = active_transitions.length;\n\n\tif (length > 0) {\n\t\tvar i = 0;\n\t\tvar block;\n\t\tvar transition;\n\n\t\tfor (; i < length; i++) {\n\t\t\tblock = active_transitions[i];\n\t\t\ttransition = block.r;\n\t\t\tif (transition !== null) {\n\t\t\t\tblock.r = null;\n\t\t\t\tdestroy_each_item_block(block, null, false);\n\t\t\t}\n\t\t}\n\n\t\tactive_transitions.length = 0;\n\t}\n}\n\n/**\n * @param {import('../../types.js').Block} block\n * @returns {Text | Element | Comment}\n */\nexport function get_first_element(block) {\n\tconst current = block.d;\n\n\tif (is_array(current)) {\n\t\tfor (let i = 0; i < current.length; i++) {\n\t\t\tconst node = current[i];\n\t\t\tif (node.nodeType !== 8) {\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn /** @type {Text | Element | Comment} */ (current);\n}\n\n/**\n * @param {import('../../types.js').EachItemBlock} block\n * @param {any} item\n * @param {number} index\n * @param {number} type\n * @returns {void}\n */\nfunction update_each_item_block(block, item, index, type) {\n\tconst block_v = block.v;\n\tif ((type & EACH_ITEM_REACTIVE) !== 0) {\n\t\tset(block_v, item);\n\t}\n\tconst transitions = block.s;\n\tconst index_is_reactive = (type & EACH_INDEX_REACTIVE) !== 0;\n\t// Handle each item animations\n\tconst each_animation = block.a;\n\tif (transitions !== null && (type & EACH_KEYED) !== 0 && each_animation !== null) {\n\t\teach_animation(block, transitions);\n\t}\n\tif (index_is_reactive) {\n\t\tset(/** @type {import('../../types.js').Value<number>} */ (block.i), index);\n\t} else {\n\t\tblock.i = index;\n\t}\n}\n\n/**\n * @param {import('../../types.js').EachItemBlock} block\n * @param {null | Array<import('../../types.js').Block>} transition_block\n * @param {boolean} apply_transitions\n * @param {any} controlled\n * @returns {void}\n */\nexport function destroy_each_item_block(\n\tblock,\n\ttransition_block,\n\tapply_transitions,\n\tcontrolled = false\n) {\n\tconst transitions = block.s;\n\n\tif (apply_transitions && transitions !== null) {\n\t\t// We might have pending key transitions, if so remove them first\n\t\tfor (let other of transitions) {\n\t\t\tif (other.r === 'key') {\n\t\t\t\ttransitions.delete(other);\n\t\t\t}\n\t\t}\n\t\tif (transitions.size === 0) {\n\t\t\tblock.s = null;\n\t\t} else {\n\t\t\ttrigger_transitions(transitions, 'out');\n\t\t\tif (transition_block !== null) {\n\t\t\t\ttransition_block.push(block);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\tconst dom = block.d;\n\tif (!controlled && dom !== null) {\n\t\tremove(dom);\n\t}\n\tdestroy_effect(/** @type {import('#client').Effect} */ (block.e));\n}\n\n/**\n * @template V\n * @param {V} item\n * @param {unknown} key\n * @param {number} index\n * @param {(anchor: null, item: V, index: number | import('../../types.js').Value<number>) => void} render_fn\n * @param {number} flags\n * @returns {import('../../types.js').EachItemBlock}\n */\nfunction each_item_block(item, key, index, render_fn, flags) {\n\tconst each_item_not_reactive = (flags & EACH_ITEM_REACTIVE) === 0;\n\n\tconst item_value = each_item_not_reactive\n\t\t? item\n\t\t: (flags & EACH_IS_STRICT_EQUALS) !== 0\n\t\t\t? source(item)\n\t\t\t: mutable_source(item);\n\n\tconst index_value = (flags & EACH_INDEX_REACTIVE) === 0 ? index : source(index);\n\tconst block = create_each_item_block(item_value, index_value, key);\n\n\tconst effect = render_effect(\n\t\t/** @param {import('../../types.js').EachItemBlock} block */\n\t\t(block) => {\n\t\t\trender_fn(null, block.v, block.i);\n\t\t},\n\t\tblock,\n\t\ttrue\n\t);\n\n\tblock.e = effect;\n\treturn block;\n}\n","import { EACH_IS_ANIMATED, EACH_IS_CONTROLLED } from '../../../../constants.js';\nimport { run_all } from '../../../common.js';\nimport {\n\tAWAIT_BLOCK,\n\tDYNAMIC_COMPONENT_BLOCK,\n\tEACH_BLOCK,\n\tEACH_ITEM_BLOCK,\n\tIF_BLOCK,\n\tKEY_BLOCK,\n\tROOT_BLOCK\n} from '../../constants.js';\nimport { destroy_each_item_block, get_first_element } from '../blocks/each.js';\nimport { schedule_raf_task } from '../task.js';\nimport { append_child, empty } from '../operations.js';\nimport {\n\tdestroy_effect,\n\teffect,\n\tmanaged_effect,\n\tmanaged_pre_effect\n} from '../../reactivity/effects.js';\nimport {\n\tcurrent_block,\n\tcurrent_effect,\n\texecute_effect,\n\tmark_subtree_inert,\n\tuntrack\n} from '../../runtime.js';\nimport { raf } from '../../timing.js';\n\nconst active_tick_animations = new Set();\nconst DELAY_NEXT_TICK = Number.MIN_SAFE_INTEGER;\n\n/** @type {undefined | number} */\nlet active_tick_ref = undefined;\n\n/**\n * @template P\n * @param {HTMLElement} dom\n * @param {() => import('#client').TransitionFn<P | undefined>} get_transition_fn\n * @param {(() => P) | null} props\n * @param {any} global\n * @returns {void}\n */\nexport function transition(dom, get_transition_fn, props, global = false) {\n\tbind_transition(dom, get_transition_fn, props, 'both', global);\n}\n\n/**\n * @template P\n * @param {HTMLElement} dom\n * @param {() => import('#client').TransitionFn<P | undefined>} get_transition_fn\n * @param {(() => P) | null} props\n * @returns {void}\n */\nexport function animate(dom, get_transition_fn, props) {\n\tbind_transition(dom, get_transition_fn, props, 'key', false);\n}\n\n/**\n * @template P\n * @param {HTMLElement} dom\n * @param {() => import('#client').TransitionFn<P | undefined>} get_transition_fn\n * @param {(() => P) | null} props\n * @param {any} global\n * @returns {void}\n */\nfunction in_fn(dom, get_transition_fn, props, global = false) {\n\tbind_transition(dom, get_transition_fn, props, 'in', global);\n}\nexport { in_fn as in };\n\n/**\n * @template P\n * @param {HTMLElement} dom\n * @param {() => import('#client').TransitionFn<P | undefined>} get_transition_fn\n * @param {(() => P) | null} props\n * @param {any} global\n * @returns {void}\n */\nexport function out(dom, get_transition_fn, props, global = false) {\n\tbind_transition(dom, get_transition_fn, props, 'out', global);\n}\n\n/**\n * @template T\n * @param {string} type\n * @param {T} [detail]\n * @param {any}params_0\n * @returns {Event}\n */\nfunction custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n\tconst e = document.createEvent('CustomEvent');\n\te.initCustomEvent(type, bubbles, cancelable, detail);\n\treturn e;\n}\n\n/**\n * @param {HTMLElement} dom\n * @param {'introstart' | 'introend' | 'outrostart' | 'outroend'} type\n * @returns {void}\n */\nfunction dispatch_event(dom, type) {\n\tdom.dispatchEvent(custom_event(type));\n}\n\n/**\n * @param {string} style\n * @returns {string}\n */\nfunction css_style_from_camel_case(style) {\n\tconst parts = style.split('-');\n\tif (parts.length === 1) return parts[0];\n\treturn (\n\t\tparts[0] +\n\t\tparts\n\t\t\t.slice(1)\n\t\t\t.map(/** @param {any} word */ (word) => word[0].toUpperCase() + word.slice(1))\n\t\t\t.join('')\n\t);\n}\n\n/**\n * @param {string} css\n * @returns {Keyframe}\n */\nfunction css_to_keyframe(css) {\n\t/** @type {Keyframe} */\n\tconst keyframe = {};\n\tconst parts = css.split(';');\n\tfor (const part of parts) {\n\t\tconst [property, value] = part.split(':');\n\t\tif (!property || value === undefined) break;\n\n\t\tconst formatted_property = css_style_from_camel_case(property.trim());\n\t\tkeyframe[formatted_property] = value.trim();\n\t}\n\treturn keyframe;\n}\n\nclass TickAnimation {\n\t/** @type {null | (() => void)} */\n\tonfinish;\n\n\t/** @type {(t: number, u: number) => string} */\n\t#tick_fn;\n\n\t/** @type {number} */\n\t#duration;\n\n\t/** @type {number} */\n\t#current;\n\n\t/** @type {number} */\n\t#delay;\n\n\t/** @type {number} */\n\t#previous;\n\n\t/** @type {boolean} */\n\tpaused;\n\n\t/** @type {boolean} */\n\t#reversed;\n\n\t/** @type {number} */\n\t#delay_current;\n\n\t/** @type {boolean} */\n\t#delayed_reverse;\n\n\t/**\n\t * @param {(t: number, u: number) => string} tick_fn\n\t * @param {number} duration\n\t * @param {number} delay\n\t * @param {boolean} out\n\t */\n\tconstructor(tick_fn, duration, delay, out) {\n\t\tthis.#duration = duration;\n\t\tthis.#delay = delay;\n\t\tthis.paused = false;\n\t\tthis.#tick_fn = tick_fn;\n\t\tthis.#reversed = out;\n\t\tthis.#delay_current = delay;\n\t\tthis.#current = out ? duration : 0;\n\t\tthis.#previous = 0;\n\t\tthis.#delayed_reverse = false;\n\t\tthis.onfinish = null;\n\t\tif (this.#delay) {\n\t\t\tif (!out) {\n\t\t\t\tthis.#tick_fn(0, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tpause() {\n\t\tthis.paused = true;\n\t}\n\n\tplay() {\n\t\tthis.paused = false;\n\t\tif (!active_tick_animations.has(this)) {\n\t\t\tthis.#previous = raf.now();\n\t\t\tif (active_tick_ref === undefined) {\n\t\t\t\tactive_tick_ref = raf.tick(handle_raf);\n\t\t\t}\n\t\t\tactive_tick_animations.add(this);\n\t\t}\n\t}\n\n\t#reverse() {\n\t\tthis.#reversed = !this.#reversed;\n\t\tif (this.paused) {\n\t\t\tif (this.#current === 0) {\n\t\t\t\tthis.#current = this.#duration;\n\t\t\t}\n\t\t\tthis.play();\n\t\t}\n\t}\n\n\treverse() {\n\t\tif (this.#delay === 0) {\n\t\t\tthis.#reverse();\n\t\t} else {\n\t\t\tthis.#delay_current = this.#delay;\n\t\t\tthis.#delayed_reverse = true;\n\t\t}\n\t}\n\n\tcancel() {\n\t\tactive_tick_animations.delete(this);\n\t\tconst current = this.#current / this.#duration;\n\t\tif (current > 0 && current < 1) {\n\t\t\tconst t = this.#reversed ? 1 : 0;\n\t\t\tthis.#tick_fn(t, 1 - t);\n\t\t}\n\t}\n\n\tfinish() {\n\t\tactive_tick_animations.delete(this);\n\t\tif (this.onfinish) {\n\t\t\tthis.onfinish();\n\t\t}\n\t}\n\n\t/** @param {number} time */\n\t_update(time) {\n\t\tlet diff = time - this.#previous;\n\t\tthis.#previous = time;\n\t\tif (this.#delay_current !== 0) {\n\t\t\tconst is_delayed = this.#delay_current === DELAY_NEXT_TICK;\n\t\t\tlet cancel = !this.#delayed_reverse;\n\t\t\tthis.#delay_current -= diff;\n\t\t\tif (this.#delay_current < 0 || is_delayed || (this.#delay_current === 0 && this.#reversed)) {\n\t\t\t\tconst delay_diff = is_delayed ? 0 : -this.#delay_current;\n\t\t\t\tthis.#delay_current = 0;\n\n\t\t\t\tif (this.#delayed_reverse) {\n\t\t\t\t\tthis.#delayed_reverse = false;\n\t\t\t\t\tthis.#reverse();\n\t\t\t\t} else if (delay_diff !== 0 || this.#reversed) {\n\t\t\t\t\tdiff = delay_diff;\n\t\t\t\t}\n\t\t\t\tcancel = false;\n\t\t\t} else if (this.#delay_current === 0) {\n\t\t\t\tthis.#delay_current = DELAY_NEXT_TICK;\n\t\t\t}\n\t\t\tif (cancel) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthis.#current += this.#reversed ? -diff : diff;\n\t\tlet t = this.#current / this.#duration;\n\n\t\tif (t < 0) {\n\t\t\tt = 0;\n\t\t} else if (t > 1) {\n\t\t\tt = 1;\n\t\t}\n\n\t\tif ((this.#reversed && t <= 0) || (!this.#reversed && t >= 1)) {\n\t\t\tt = this.#reversed ? 0 : 1;\n\t\t\tif (this.#delay_current === 0) {\n\t\t\t\tactive_tick_animations.delete(this);\n\t\t\t\tif (this.onfinish) {\n\t\t\t\t\tthis.paused = true;\n\t\t\t\t\tthis.onfinish();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.#tick_fn(t, 1 - t);\n\t}\n}\n\n/** @param {number} time */\nfunction handle_raf(time) {\n\tfor (const animation of active_tick_animations) {\n\t\tif (!animation.paused) {\n\t\t\tanimation._update(time);\n\t\t}\n\t}\n\tif (active_tick_animations.size !== 0) {\n\t\tactive_tick_ref = raf.tick(handle_raf);\n\t} else {\n\t\tactive_tick_ref = undefined;\n\t}\n}\n\n/**\n * @param {{(t: number): number;(t: number): number;(arg0: number): any;}} easing_fn\n * @param {((t: number, u: number) => string)} css_fn\n * @param {number} duration\n * @param {string} direction\n * @param {boolean} reverse\n */\nfunction create_keyframes(easing_fn, css_fn, duration, direction, reverse) {\n\t/** @type {Keyframe[]} */\n\tconst keyframes = [];\n\t// We need at least two frames\n\tconst frame_time = 16.666;\n\tconst max_duration = Math.max(duration, frame_time);\n\t// Have a keyframe every fame for 60 FPS\n\tfor (let i = 0; i <= max_duration; i += frame_time) {\n\t\tlet time;\n\t\tif (i + frame_time > max_duration) {\n\t\t\ttime = 1;\n\t\t} else if (i === 0) {\n\t\t\ttime = 0;\n\t\t} else {\n\t\t\ttime = i / max_duration;\n\t\t}\n\t\tlet t = easing_fn(time);\n\t\tif (reverse) {\n\t\t\tt = 1 - t;\n\t\t}\n\t\tkeyframes.push(css_to_keyframe(css_fn(t, 1 - t)));\n\t}\n\tif (direction === 'out' || reverse) {\n\t\tkeyframes.reverse();\n\t}\n\treturn keyframes;\n}\n\n/** @param {number} t */\nconst linear = (t) => t;\n\n/**\n * @param {HTMLElement} dom\n * @param {() => import('../../types.js').TransitionPayload} init\n * @param {'in' | 'out' | 'both' | 'key'} direction\n * @param {import('../../types.js').Effect} effect\n * @returns {import('../../types.js').Transition}\n */\nfunction create_transition(dom, init, direction, effect) {\n\tlet curr_direction = 'in';\n\n\t/** @type {Array<() => void>} */\n\tlet subs = [];\n\n\t/** @type {null | Animation | TickAnimation} */\n\tlet animation = null;\n\tlet cancelled = false;\n\n\tconst create_animation = () => {\n\t\tlet payload = /** @type {import('../../types.js').TransitionPayload} */ (transition.p);\n\t\tif (typeof payload === 'function') {\n\t\t\t// @ts-ignore\n\t\t\tpayload = payload({ direction: curr_direction });\n\t\t}\n\t\tif (payload == null) {\n\t\t\treturn;\n\t\t}\n\t\tconst duration = payload.duration ?? 300;\n\t\tconst delay = payload.delay ?? 0;\n\t\tconst css_fn = payload.css;\n\t\tconst tick_fn = payload.tick;\n\t\tconst easing_fn = payload.easing || linear;\n\n\t\tif (typeof tick_fn === 'function') {\n\t\t\tanimation = new TickAnimation(tick_fn, duration, delay, direction === 'out');\n\t\t} else {\n\t\t\tconst keyframes =\n\t\t\t\ttypeof css_fn === 'function'\n\t\t\t\t\t? create_keyframes(easing_fn, css_fn, duration, direction, false)\n\t\t\t\t\t: [];\n\t\t\tanimation = dom.animate(keyframes, {\n\t\t\t\tduration,\n\t\t\t\tendDelay: delay,\n\t\t\t\tdelay,\n\t\t\t\tfill: 'both'\n\t\t\t});\n\t\t}\n\t\tanimation.pause();\n\n\t\tanimation.onfinish = () => {\n\t\t\tconst is_outro = curr_direction === 'out';\n\t\t\t/** @type {Animation | TickAnimation} */ (animation).cancel();\n\t\t\tif (is_outro) {\n\t\t\t\trun_all(subs);\n\t\t\t\tsubs = [];\n\t\t\t}\n\t\t\tdispatch_event(dom, is_outro ? 'outroend' : 'introend');\n\t\t};\n\t};\n\n\t/** @type {import('../../types.js').Transition} */\n\tconst transition = {\n\t\te: effect,\n\t\ti: init,\n\t\t// payload\n\t\tp: null,\n\n\t\t// finished\n\t\t/** @param {() => void} fn */\n\t\tf(fn) {\n\t\t\tsubs.push(fn);\n\t\t},\n\t\tin() {\n\t\t\tconst needs_reverse = curr_direction !== 'in';\n\t\t\tcurr_direction = 'in';\n\t\t\tif (animation === null || cancelled) {\n\t\t\t\tcancelled = false;\n\t\t\t\tcreate_animation();\n\t\t\t}\n\t\t\tif (animation === null) {\n\t\t\t\ttransition.x();\n\t\t\t} else {\n\t\t\t\tdispatch_event(dom, 'introstart');\n\t\t\t\tif (needs_reverse) {\n\t\t\t\t\t/** @type {Animation | TickAnimation} */ (animation).reverse();\n\t\t\t\t}\n\t\t\t\t/** @type {Animation | TickAnimation} */ (animation).play();\n\t\t\t}\n\t\t},\n\t\t// out\n\t\to() {\n\t\t\t// @ts-ignore\n\t\t\tconst has_keyed_transition = dom.__animate;\n\t\t\t// If we're outroing an element that has an animation, then we need to fix\n\t\t\t// its position to ensure it behaves nicely without causing layout shift.\n\t\t\tif (has_keyed_transition) {\n\t\t\t\tconst style = getComputedStyle(dom);\n\t\t\t\tconst position = style.position;\n\n\t\t\t\tif (position !== 'absolute' && position !== 'fixed') {\n\t\t\t\t\tconst { width, height } = style;\n\t\t\t\t\tconst a = dom.getBoundingClientRect();\n\t\t\t\t\tdom.style.position = 'absolute';\n\n\t\t\t\t\tdom.style.width = width;\n\t\t\t\t\tdom.style.height = height;\n\t\t\t\t\tconst b = dom.getBoundingClientRect();\n\t\t\t\t\tif (a.left !== b.left || a.top !== b.top) {\n\t\t\t\t\t\tconst translate = `translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n\t\t\t\t\t\tconst existing_transform = style.transform;\n\t\t\t\t\t\tif (existing_transform === 'none') {\n\t\t\t\t\t\t\tdom.style.transform = translate;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Previously, in the Svelte 4, we'd just apply the transform the the DOM element. However,\n\t\t\t\t\t\t\t// because we're now using Web Animations, we can't do that as it won't work properly if the\n\t\t\t\t\t\t\t// animation is also making use of the same transformations. So instead, we apply an\n\t\t\t\t\t\t\t// instantaneous animation and pause it on the first frame, just applying the same behavior.\n\t\t\t\t\t\t\t// We also need to take into consideration matrix transforms and how they might combine with\n\t\t\t\t\t\t\t// an existing behavior that is already in progress (such as scale).\n\t\t\t\t\t\t\t// > Follow the white rabbit.\n\t\t\t\t\t\t\tconst transform = existing_transform.startsWith('matrix(1,')\n\t\t\t\t\t\t\t\t? translate\n\t\t\t\t\t\t\t\t: `matrix(1,0,0,1,0,0)`;\n\t\t\t\t\t\t\tconst frame = {\n\t\t\t\t\t\t\t\ttransform\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tconst animation = dom.animate([frame, frame], { duration: 1 });\n\t\t\t\t\t\t\tanimation.pause();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst needs_reverse = direction === 'both' && curr_direction !== 'out';\n\t\t\tcurr_direction = 'out';\n\t\t\tif (animation === null || cancelled) {\n\t\t\t\tcancelled = false;\n\t\t\t\tcreate_animation();\n\t\t\t}\n\t\t\tif (animation === null) {\n\t\t\t\ttransition.x();\n\t\t\t} else {\n\t\t\t\tdispatch_event(dom, 'outrostart');\n\t\t\t\tif (needs_reverse) {\n\t\t\t\t\tconst payload = transition.p;\n\t\t\t\t\tconst current_animation = /** @type {Animation} */ (animation);\n\t\t\t\t\t// If we are working with CSS animations, then before we call reverse, we also need to ensure\n\t\t\t\t\t// that we reverse the easing logic. To do this we need to re-create the keyframes so they're\n\t\t\t\t\t// in reverse with easing properly reversed too.\n\t\t\t\t\tif (\n\t\t\t\t\t\tpayload !== null &&\n\t\t\t\t\t\tpayload.css !== undefined &&\n\t\t\t\t\t\tcurrent_animation.playState === 'idle'\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst duration = payload.duration ?? 300;\n\t\t\t\t\t\tconst css_fn = payload.css;\n\t\t\t\t\t\tconst easing_fn = payload.easing || linear;\n\t\t\t\t\t\tconst keyframes = create_keyframes(easing_fn, css_fn, duration, direction, true);\n\t\t\t\t\t\tconst effect = current_animation.effect;\n\t\t\t\t\t\tif (effect !== null) {\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\teffect.setKeyframes(keyframes);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/** @type {Animation | TickAnimation} */ (animation).reverse();\n\t\t\t\t} else {\n\t\t\t\t\t/** @type {Animation | TickAnimation} */ (animation).play();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// cancel\n\t\tc() {\n\t\t\tif (animation !== null) {\n\t\t\t\t/** @type {Animation | TickAnimation} */ (animation).cancel();\n\t\t\t}\n\t\t\tcancelled = true;\n\t\t},\n\t\t// cleanup\n\t\tx() {\n\t\t\trun_all(subs);\n\t\t\tsubs = [];\n\t\t},\n\t\tr: direction,\n\t\td: dom\n\t};\n\treturn transition;\n}\n\n/**\n * @param {import('../../types.js').Block} block\n * @returns {boolean}\n */\nfunction is_transition_block(block) {\n\tconst type = block.t;\n\treturn (\n\t\ttype === IF_BLOCK ||\n\t\ttype === EACH_ITEM_BLOCK ||\n\t\ttype === KEY_BLOCK ||\n\t\ttype === AWAIT_BLOCK ||\n\t\ttype === DYNAMIC_COMPONENT_BLOCK ||\n\t\t(type === EACH_BLOCK && block.v.length === 0)\n\t);\n}\n\n/**\n * @template P\n * @param {HTMLElement} dom\n * @param {() => import('../../types.js').TransitionFn<P | undefined> | import('../../types.js').AnimateFn<P | undefined>} get_transition_fn\n * @param {(() => P) | null} props_fn\n * @param {'in' | 'out' | 'both' | 'key'} direction\n * @param {boolean} global\n * @returns {void}\n */\nfunction bind_transition(dom, get_transition_fn, props_fn, direction, global) {\n\tconst transition_effect = /** @type {import('../../types.js').Effect} */ (current_effect);\n\tconst block = current_block;\n\tconst is_keyed_transition = direction === 'key';\n\n\tlet can_show_intro_on_mount = true;\n\tlet can_apply_lazy_transitions = false;\n\n\tif (is_keyed_transition) {\n\t\t// @ts-ignore\n\t\tdom.__animate = true;\n\t}\n\t/** @type {import('../../types.js').Block | null} */\n\tlet transition_block = block;\n\tmain: while (transition_block !== null) {\n\t\tif (is_transition_block(transition_block)) {\n\t\t\tif (transition_block.t === EACH_ITEM_BLOCK) {\n\t\t\t\t// Lazily apply the each block transition\n\t\t\t\ttransition_block.r = each_item_transition;\n\t\t\t\ttransition_block.a = each_item_animate;\n\t\t\t\ttransition_block = transition_block.p;\n\t\t\t} else if (transition_block.t === AWAIT_BLOCK && transition_block.n /* pending */) {\n\t\t\t\tcan_show_intro_on_mount = true;\n\t\t\t} else if (transition_block.t === IF_BLOCK) {\n\t\t\t\ttransition_block.r = if_block_transition;\n\t\t\t\tif (can_show_intro_on_mount) {\n\t\t\t\t\t/** @type {import('../../types.js').Block | null} */\n\t\t\t\t\tlet if_block = transition_block;\n\t\t\t\t\twhile (if_block.t === IF_BLOCK) {\n\t\t\t\t\t\t// If we have an if block parent that is currently falsy then\n\t\t\t\t\t\t// we can show the intro on mount as long as that block is mounted\n\t\t\t\t\t\tif (if_block.e !== null && !if_block.v) {\n\t\t\t\t\t\t\tcan_show_intro_on_mount = true;\n\t\t\t\t\t\t\tbreak main;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif_block = if_block.p;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!can_apply_lazy_transitions && can_show_intro_on_mount) {\n\t\t\t\tcan_show_intro_on_mount = transition_block.e !== null;\n\t\t\t}\n\t\t\tif (can_show_intro_on_mount || !global) {\n\t\t\t\tcan_apply_lazy_transitions = true;\n\t\t\t}\n\t\t} else if (transition_block.t === ROOT_BLOCK && !can_apply_lazy_transitions) {\n\t\t\tcan_show_intro_on_mount = transition_block.e !== null || transition_block.i;\n\t\t}\n\t\ttransition_block = transition_block.p;\n\t}\n\n\t/** @type {import('../../types.js').Transition} */\n\tlet transition;\n\n\teffect(() => {\n\t\tlet already_mounted = false;\n\t\tif (transition !== undefined) {\n\t\t\talready_mounted = true;\n\t\t\t// Destroy any existing transitions first\n\t\t\ttransition.x();\n\t\t}\n\t\tconst transition_fn = get_transition_fn();\n\t\t/** @param {DOMRect} [from] */\n\t\tconst init = (from) =>\n\t\t\tuntrack(() => {\n\t\t\t\tconst props = props_fn === null ? {} : props_fn();\n\t\t\t\treturn is_keyed_transition\n\t\t\t\t\t? /** @type {import('../../types.js').AnimateFn<any>} */ (transition_fn)(\n\t\t\t\t\t\t\tdom,\n\t\t\t\t\t\t\t{ from: /** @type {DOMRect} */ (from), to: dom.getBoundingClientRect() },\n\t\t\t\t\t\t\tprops,\n\t\t\t\t\t\t\t{}\n\t\t\t\t\t\t)\n\t\t\t\t\t: /** @type {import('../../types.js').TransitionFn<any>} */ (transition_fn)(dom, props, {\n\t\t\t\t\t\t\tdirection\n\t\t\t\t\t\t});\n\t\t\t});\n\n\t\ttransition = create_transition(dom, init, direction, transition_effect);\n\t\tconst is_intro = direction === 'in';\n\t\tconst show_intro = can_show_intro_on_mount && (is_intro || direction === 'both');\n\n\t\tif (show_intro && !already_mounted) {\n\t\t\ttransition.p = transition.i();\n\t\t}\n\n\t\tconst effect = managed_pre_effect(() => {\n\t\t\tdestroy_effect(effect);\n\t\t\tdom.inert = false;\n\n\t\t\tif (show_intro && !already_mounted) {\n\t\t\t\ttransition.in();\n\t\t\t}\n\n\t\t\t/** @type {import('../../types.js').Block | null} */\n\t\t\tlet transition_block = block;\n\t\t\twhile (!is_intro && transition_block !== null) {\n\t\t\t\tconst parent = transition_block.p;\n\t\t\t\tif (is_transition_block(transition_block)) {\n\t\t\t\t\tif (transition_block.r !== null) {\n\t\t\t\t\t\ttransition_block.r(transition);\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tparent === null ||\n\t\t\t\t\t\t(!global && (transition_block.t !== IF_BLOCK || parent.t !== IF_BLOCK || parent.v))\n\t\t\t\t\t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttransition_block = parent;\n\t\t\t}\n\t\t});\n\t});\n\n\tif (direction === 'key') {\n\t\teffect(() => {\n\t\t\treturn () => {\n\t\t\t\ttransition.x();\n\t\t\t};\n\t\t});\n\t}\n}\n\n/**\n * @param {Set<import('../../types.js').Transition>} transitions\n * @param {'in' | 'out' | 'key'} target_direction\n * @param {DOMRect} [from]\n * @returns {void}\n */\nexport function trigger_transitions(transitions, target_direction, from) {\n\t/** @type {Array<() => void>} */\n\tconst outros = [];\n\tfor (const transition of transitions) {\n\t\tconst direction = transition.r;\n\t\tconst effect = transition.e;\n\t\tif (target_direction === 'in') {\n\t\t\tif (direction === 'in' || direction === 'both') {\n\t\t\t\ttransition.in();\n\t\t\t} else {\n\t\t\t\ttransition.c();\n\t\t\t}\n\t\t\ttransition.d.inert = false;\n\t\t\tmark_subtree_inert(effect, false);\n\t\t} else if (target_direction === 'key') {\n\t\t\tif (direction === 'key') {\n\t\t\t\tif (!transition.p) {\n\t\t\t\t\ttransition.p = transition.i(/** @type {DOMRect} */ (from));\n\t\t\t\t}\n\t\t\t\ttransition.in();\n\t\t\t}\n\t\t} else {\n\t\t\tif (direction === 'out' || direction === 'both') {\n\t\t\t\tif (!transition.p) {\n\t\t\t\t\ttransition.p = transition.i();\n\t\t\t\t}\n\t\t\t\toutros.push(transition.o);\n\t\t\t}\n\t\t\ttransition.d.inert = true;\n\t\t\tmark_subtree_inert(effect, true);\n\t\t}\n\t}\n\tif (outros.length > 0) {\n\t\t// Defer the outros to a microtask\n\t\tconst e = managed_pre_effect(() => {\n\t\t\tdestroy_effect(e);\n\t\t\tconst e2 = managed_effect(() => {\n\t\t\t\tdestroy_effect(e2);\n\t\t\t\trun_all(outros);\n\t\t\t});\n\t\t});\n\t}\n}\n\n/**\n * @this {import('../../types.js').IfBlock}\n * @param {import('../../types.js').Transition} transition\n * @returns {void}\n */\nfunction if_block_transition(transition) {\n\tconst block = this;\n\t// block.value === true\n\tif (block.v) {\n\t\tconst consequent_transitions = (block.c ??= new Set());\n\t\tconsequent_transitions.add(transition);\n\t\ttransition.f(() => {\n\t\t\tconst c = /** @type {Set<import('../../types.js').Transition>} */ (consequent_transitions);\n\t\t\tc.delete(transition);\n\t\t\t// If the block has changed to falsy and has transitions\n\t\t\tif (!block.v && c.size === 0) {\n\t\t\t\tconst consequent_effect = block.ce;\n\t\t\t\texecute_effect(/** @type {import('../../types.js').Effect} */ (consequent_effect));\n\t\t\t}\n\t\t});\n\t} else {\n\t\tconst alternate_transitions = (block.a ??= new Set());\n\t\talternate_transitions.add(transition);\n\t\ttransition.f(() => {\n\t\t\tconst a = /** @type {Set<import('../../types.js').Transition>} */ (alternate_transitions);\n\t\t\ta.delete(transition);\n\t\t\t// If the block has changed to truthy and has transitions\n\t\t\tif (block.v && a.size === 0) {\n\t\t\t\tconst alternate_effect = block.ae;\n\t\t\t\texecute_effect(/** @type {import('../../types.js').Effect} */ (alternate_effect));\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * @this {import('../../types.js').EachItemBlock}\n * @param {import('../../types.js').Transition} transition\n * @returns {void}\n */\nfunction each_item_transition(transition) {\n\tconst block = this;\n\tconst each_block = block.p;\n\tconst is_controlled = (each_block.f & EACH_IS_CONTROLLED) !== 0;\n\t// Disable optimization\n\tif (is_controlled) {\n\t\tconst anchor = empty();\n\t\teach_block.f ^= EACH_IS_CONTROLLED;\n\t\tappend_child(/** @type {Element} */ (each_block.a), anchor);\n\t\teach_block.a = anchor;\n\t}\n\tif (transition.r === 'key' && (each_block.f & EACH_IS_ANIMATED) === 0) {\n\t\teach_block.f |= EACH_IS_ANIMATED;\n\t}\n\tconst transitions = (block.s ??= new Set());\n\ttransition.f(() => {\n\t\ttransitions.delete(transition);\n\t\tif (transition.r !== 'key') {\n\t\t\tfor (let other of transitions) {\n\t\t\t\tconst type = other.r;\n\t\t\t\tif (type === 'key' || type === 'in') {\n\t\t\t\t\ttransitions.delete(other);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (transitions.size === 0) {\n\t\t\t\tblock.s = null;\n\t\t\t\tdestroy_each_item_block(block, null, true);\n\t\t\t}\n\t\t}\n\t});\n\ttransitions.add(transition);\n}\n\n/**\n *\n * @param {import('../../types.js').EachItemBlock} block\n * @param {Set<import('../../types.js').Transition>} transitions\n */\nfunction each_item_animate(block, transitions) {\n\tconst from_dom = /** @type {Element} */ (get_first_element(block));\n\tconst from = from_dom.getBoundingClientRect();\n\t// Cancel any existing key transitions\n\tfor (const transition of transitions) {\n\t\tconst type = transition.r;\n\t\tif (type === 'key') {\n\t\t\ttransition.c();\n\t\t}\n\t}\n\tschedule_raf_task(() => {\n\t\ttrigger_transitions(transitions, 'key', from);\n\t});\n}\n","import { is_promise } from '../../../common.js';\nimport { hydrate_block_anchor } from '../hydration.js';\nimport { remove } from '../reconciler.js';\nimport { current_block, execute_effect, flushSync } from '../../runtime.js';\nimport { destroy_effect, render_effect } from '../../reactivity/effects.js';\nimport { trigger_transitions } from '../elements/transitions.js';\nimport { AWAIT_BLOCK, UNINITIALIZED } from '../../constants.js';\n\n/** @returns {import('../../types.js').AwaitBlock} */\nexport function create_await_block() {\n\treturn {\n\t\t// dom\n\t\td: null,\n\t\t// effect\n\t\te: null,\n\t\t// parent\n\t\tp: /** @type {import('../../types.js').Block} */ (current_block),\n\t\t// pending\n\t\tn: true,\n\t\t// transition\n\t\tr: null,\n\t\t// type\n\t\tt: AWAIT_BLOCK\n\t};\n}\n\n/**\n * @template V\n * @param {Comment} anchor_node\n * @param {(() => Promise<V>)} input\n * @param {null | ((anchor: Node) => void)} pending_fn\n * @param {null | ((anchor: Node, value: V) => void)} then_fn\n * @param {null | ((anchor: Node, error: unknown) => void)} catch_fn\n * @returns {void}\n */\nexport function await_block(anchor_node, input, pending_fn, then_fn, catch_fn) {\n\tconst block = create_await_block();\n\n\t/** @type {null | import('../../types.js').Render} */\n\tlet current_render = null;\n\thydrate_block_anchor(anchor_node);\n\n\t/** @type {{}} */\n\tlet latest_token;\n\n\t/** @type {typeof UNINITIALIZED | V} */\n\tlet resolved_value = UNINITIALIZED;\n\n\t/** @type {unknown} */\n\tlet error = UNINITIALIZED;\n\tlet pending = false;\n\tblock.r =\n\t\t/**\n\t\t * @param {import('../../types.js').Transition} transition\n\t\t * @returns {void}\n\t\t */\n\t\t(transition) => {\n\t\t\tconst render = /** @type {import('../../types.js').Render} */ (current_render);\n\t\t\tconst transitions = render.s;\n\t\t\ttransitions.add(transition);\n\t\t\ttransition.f(() => {\n\t\t\t\ttransitions.delete(transition);\n\t\t\t\tif (transitions.size === 0) {\n\t\t\t\t\t// If the current render has changed since, then we can remove the old render\n\t\t\t\t\t// effect as it's stale.\n\t\t\t\t\tif (current_render !== render && render.e !== null) {\n\t\t\t\t\t\tif (render.d !== null) {\n\t\t\t\t\t\t\tremove(render.d);\n\t\t\t\t\t\t\trender.d = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdestroy_effect(render.e);\n\t\t\t\t\t\trender.e = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\tconst create_render_effect = () => {\n\t\t/** @type {import('../../types.js').Render} */\n\t\tconst render = {\n\t\t\td: null,\n\t\t\te: null,\n\t\t\ts: new Set(),\n\t\t\tp: current_render\n\t\t};\n\t\tconst effect = render_effect(\n\t\t\t() => {\n\t\t\t\tif (error === UNINITIALIZED) {\n\t\t\t\t\tif (resolved_value === UNINITIALIZED) {\n\t\t\t\t\t\t// pending = true\n\t\t\t\t\t\tblock.n = true;\n\t\t\t\t\t\tif (pending_fn !== null) {\n\t\t\t\t\t\t\tpending_fn(anchor_node);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (then_fn !== null) {\n\t\t\t\t\t\t// pending = false\n\t\t\t\t\t\tblock.n = false;\n\t\t\t\t\t\tthen_fn(anchor_node, resolved_value);\n\t\t\t\t\t}\n\t\t\t\t} else if (catch_fn !== null) {\n\t\t\t\t\t// pending = false\n\t\t\t\t\tblock.n = false;\n\t\t\t\t\tcatch_fn(anchor_node, error);\n\t\t\t\t}\n\t\t\t\trender.d = block.d;\n\t\t\t\tblock.d = null;\n\t\t\t},\n\t\t\tblock,\n\t\t\ttrue,\n\t\t\ttrue\n\t\t);\n\t\trender.e = effect;\n\t\tcurrent_render = render;\n\t};\n\tconst render = () => {\n\t\tconst render = current_render;\n\t\tif (render === null) {\n\t\t\tcreate_render_effect();\n\t\t\treturn;\n\t\t}\n\t\tconst transitions = render.s;\n\t\tif (transitions.size === 0) {\n\t\t\tif (render.d !== null) {\n\t\t\t\tremove(render.d);\n\t\t\t\trender.d = null;\n\t\t\t}\n\t\t\tif (render.e) {\n\t\t\t\texecute_effect(render.e);\n\t\t\t} else {\n\t\t\t\tcreate_render_effect();\n\t\t\t}\n\t\t} else {\n\t\t\tcreate_render_effect();\n\t\t\ttrigger_transitions(transitions, 'out');\n\t\t}\n\t};\n\tconst await_effect = render_effect(\n\t\t() => {\n\t\t\tconst token = {};\n\t\t\tlatest_token = token;\n\t\t\tconst promise = input();\n\t\t\tif (is_promise(promise)) {\n\t\t\t\tpromise.then(\n\t\t\t\t\t/** @param {V} v */\n\t\t\t\t\t(v) => {\n\t\t\t\t\t\tif (latest_token === token) {\n\t\t\t\t\t\t\t// Ensure UI is in sync before resolving value.\n\t\t\t\t\t\t\tflushSync();\n\t\t\t\t\t\t\tresolved_value = v;\n\t\t\t\t\t\t\tpending = false;\n\t\t\t\t\t\t\trender();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t/** @param {unknown} _error */\n\t\t\t\t\t(_error) => {\n\t\t\t\t\t\terror = _error;\n\t\t\t\t\t\tpending = false;\n\t\t\t\t\t\trender();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tif (resolved_value !== UNINITIALIZED || error !== UNINITIALIZED) {\n\t\t\t\t\terror = UNINITIALIZED;\n\t\t\t\t\tresolved_value = UNINITIALIZED;\n\t\t\t\t}\n\t\t\t\tif (!pending) {\n\t\t\t\t\tpending = true;\n\t\t\t\t\trender();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terror = UNINITIALIZED;\n\t\t\t\tresolved_value = promise;\n\t\t\t\tpending = false;\n\t\t\t\trender();\n\t\t\t}\n\t\t},\n\t\tblock,\n\t\tfalse\n\t);\n\tawait_effect.ondestroy = () => {\n\t\tlet render = current_render;\n\t\tlatest_token = {};\n\t\twhile (render !== null) {\n\t\t\tconst dom = render.d;\n\t\t\tif (dom !== null) {\n\t\t\t\tremove(dom);\n\t\t\t}\n\t\t\tconst effect = render.e;\n\t\t\tif (effect !== null) {\n\t\t\t\tdestroy_effect(effect);\n\t\t\t}\n\t\t\trender = render.p;\n\t\t}\n\t};\n\tblock.e = await_effect;\n}\n","import { IF_BLOCK } from '../../constants.js';\nimport {\n\tcurrent_hydration_fragment,\n\thydrate_block_anchor,\n\thydrating,\n\tset_current_hydration_fragment\n} from '../hydration.js';\nimport { remove } from '../reconciler.js';\nimport { current_block, execute_effect } from '../../runtime.js';\nimport { destroy_effect, render_effect } from '../../reactivity/effects.js';\nimport { trigger_transitions } from '../elements/transitions.js';\n\n/** @returns {import('#client').IfBlock} */\nfunction create_if_block() {\n\treturn {\n\t\t// alternate transitions\n\t\ta: null,\n\t\t// alternate effect\n\t\tae: null,\n\t\t// consequent transitions\n\t\tc: null,\n\t\t// consequent effect\n\t\tce: null,\n\t\t// dom\n\t\td: null,\n\t\t// effect\n\t\te: null,\n\t\t// parent\n\t\tp: /** @type {import('#client').Block} */ (current_block),\n\t\t// transition\n\t\tr: null,\n\t\t// type\n\t\tt: IF_BLOCK,\n\t\t// value\n\t\tv: false\n\t};\n}\n\n/**\n * @param {Comment} anchor_node\n * @param {() => boolean} condition_fn\n * @param {(anchor: Node) => void} consequent_fn\n * @param {null | ((anchor: Node) => void)} alternate_fn\n * @returns {void}\n */\nexport function if_block(anchor_node, condition_fn, consequent_fn, alternate_fn) {\n\tconst block = create_if_block();\n\n\thydrate_block_anchor(anchor_node);\n\n\t/** Whether or not there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\tlet mismatch = false;\n\n\t/** @type {null | import('#client').TemplateNode | Array<import('#client').TemplateNode>} */\n\tlet consequent_dom = null;\n\n\t/** @type {null | import('#client').TemplateNode | Array<import('#client').TemplateNode>} */\n\tlet alternate_dom = null;\n\n\tlet has_mounted = false;\n\n\t/**\n\t * @type {import('#client').Effect | null}\n\t */\n\tlet current_branch_effect = null;\n\n\t/** @type {import('#client').Effect} */\n\tlet consequent_effect;\n\n\t/** @type {import('#client').Effect} */\n\tlet alternate_effect;\n\n\tconst if_effect = render_effect(() => {\n\t\tconst result = !!condition_fn();\n\n\t\tif (block.v !== result || !has_mounted) {\n\t\t\tblock.v = result;\n\n\t\t\tif (has_mounted) {\n\t\t\t\tconst consequent_transitions = block.c;\n\t\t\t\tconst alternate_transitions = block.a;\n\n\t\t\t\tif (result) {\n\t\t\t\t\tif (alternate_transitions === null || alternate_transitions.size === 0) {\n\t\t\t\t\t\texecute_effect(alternate_effect);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttrigger_transitions(alternate_transitions, 'out');\n\t\t\t\t\t}\n\n\t\t\t\t\tif (consequent_transitions === null || consequent_transitions.size === 0) {\n\t\t\t\t\t\texecute_effect(consequent_effect);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttrigger_transitions(consequent_transitions, 'in');\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (consequent_transitions === null || consequent_transitions.size === 0) {\n\t\t\t\t\t\texecute_effect(consequent_effect);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttrigger_transitions(consequent_transitions, 'out');\n\t\t\t\t\t}\n\n\t\t\t\t\tif (alternate_transitions === null || alternate_transitions.size === 0) {\n\t\t\t\t\t\texecute_effect(alternate_effect);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttrigger_transitions(alternate_transitions, 'in');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (hydrating) {\n\t\t\t\tconst comment_text = /** @type {Comment} */ (current_hydration_fragment?.[0])?.data;\n\n\t\t\t\tif (\n\t\t\t\t\t!comment_text ||\n\t\t\t\t\t(comment_text === 'ssr:if:true' && !result) ||\n\t\t\t\t\t(comment_text === 'ssr:if:false' && result)\n\t\t\t\t) {\n\t\t\t\t\t// Hydration mismatch: remove everything inside the anchor and start fresh.\n\t\t\t\t\t// This could happen using when `{#if browser} .. {/if}` in SvelteKit.\n\t\t\t\t\tremove(current_hydration_fragment);\n\t\t\t\t\tset_current_hydration_fragment(null);\n\t\t\t\t\tmismatch = true;\n\t\t\t\t} else {\n\t\t\t\t\t// Remove the ssr:if comment node or else it will confuse the subsequent hydration algorithm\n\t\t\t\t\tcurrent_hydration_fragment.shift();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thas_mounted = true;\n\t\t}\n\n\t\t// create these here so they have the correct parent/child relationship\n\t\tconsequent_effect ??= render_effect(\n\t\t\t(/** @type {any} */ _, /** @type {import('#client').Effect | null} */ consequent_effect) => {\n\t\t\t\tconst result = block.v;\n\n\t\t\t\tif (!result && consequent_dom !== null) {\n\t\t\t\t\tremove(consequent_dom);\n\t\t\t\t\tconsequent_dom = null;\n\t\t\t\t}\n\n\t\t\t\tif (result && current_branch_effect !== consequent_effect) {\n\t\t\t\t\tconsequent_fn(anchor_node);\n\t\t\t\t\tif (mismatch && current_branch_effect === null) {\n\t\t\t\t\t\t// Set fragment so that Svelte continues to operate in hydration mode\n\t\t\t\t\t\tset_current_hydration_fragment([]);\n\t\t\t\t\t}\n\t\t\t\t\tcurrent_branch_effect = consequent_effect;\n\t\t\t\t\tconsequent_dom = block.d;\n\t\t\t\t}\n\n\t\t\t\tblock.d = null;\n\t\t\t},\n\t\t\tblock,\n\t\t\ttrue\n\t\t);\n\t\tblock.ce = consequent_effect;\n\n\t\talternate_effect ??= render_effect(\n\t\t\t(/** @type {any} */ _, /** @type {import('#client').Effect | null} */ alternate_effect) => {\n\t\t\t\tconst result = block.v;\n\n\t\t\t\tif (result && alternate_dom !== null) {\n\t\t\t\t\tremove(alternate_dom);\n\t\t\t\t\talternate_dom = null;\n\t\t\t\t}\n\n\t\t\t\tif (!result && current_branch_effect !== alternate_effect) {\n\t\t\t\t\tif (alternate_fn !== null) {\n\t\t\t\t\t\talternate_fn(anchor_node);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (mismatch && current_branch_effect === null) {\n\t\t\t\t\t\t// Set fragment so that Svelte continues to operate in hydration mode\n\t\t\t\t\t\tset_current_hydration_fragment([]);\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrent_branch_effect = alternate_effect;\n\t\t\t\t\talternate_dom = block.d;\n\t\t\t\t}\n\t\t\t\tblock.d = null;\n\t\t\t},\n\t\t\tblock,\n\t\t\ttrue\n\t\t);\n\t\tblock.ae = alternate_effect;\n\t}, block);\n\n\tif_effect.ondestroy = () => {\n\t\tif (consequent_dom !== null) {\n\t\t\tremove(consequent_dom);\n\t\t}\n\n\t\tif (alternate_dom !== null) {\n\t\t\tremove(alternate_dom);\n\t\t}\n\n\t\tdestroy_effect(consequent_effect);\n\t\tdestroy_effect(alternate_effect);\n\t};\n\n\tblock.e = if_effect;\n}\n","import { render_effect } from '../../reactivity/effects.js';\nimport { reconcile_html, remove } from '../reconciler.js';\n\n/**\n * @param {Element | Text | Comment} dom\n * @param {() => string} get_value\n * @param {boolean} svg\n * @returns {void}\n */\nexport function html(dom, get_value, svg) {\n\t/** @type {import('#client').TemplateNode | import('#client').TemplateNode[]} */\n\tlet html_dom;\n\n\t/** @type {string} */\n\tlet value;\n\n\tconst effect = render_effect(() => {\n\t\tif (value !== (value = get_value())) {\n\t\t\tif (html_dom) remove(html_dom);\n\t\t\thtml_dom = reconcile_html(dom, value, svg);\n\t\t}\n\t});\n\n\teffect.ondestroy = () => {\n\t\tif (html_dom) {\n\t\t\tremove(html_dom);\n\t\t}\n\t};\n}\n","import { DEV } from 'esm-env';\nimport { append_child, create_element, empty, init_operations } from './dom/operations.js';\nimport { PassiveDelegatedEvents } from '../../constants.js';\nimport { remove } from './dom/reconciler.js';\nimport { flush_sync, push, pop, current_component_context } from './runtime.js';\nimport { render_effect, destroy_effect } from './reactivity/effects.js';\nimport {\n\tcurrent_hydration_fragment,\n\tget_hydration_fragment,\n\thydrate_block_anchor,\n\thydrating,\n\tset_current_hydration_fragment\n} from './dom/hydration.js';\nimport { array_from } from './utils.js';\nimport { ROOT_BLOCK } from './constants.js';\nimport { handle_event_propagation } from './dom/elements/events.js';\n\n/** @type {Set<string>} */\nexport const all_registered_events = new Set();\n\n/** @type {Set<(events: Array<string>) => void>} */\nexport const root_event_handles = new Set();\n\n/**\n * @param {Element} dom\n * @param {() => string} value\n * @returns {void}\n */\nexport function text_effect(dom, value) {\n\trender_effect(() => text(dom, value()));\n}\n\n/**\n * @param {Element} dom\n * @param {string} value\n * @returns {void}\n */\nexport function text(dom, value) {\n\t// @ts-expect-error need to add __value to patched prototype\n\tconst prev_node_value = dom.__nodeValue;\n\tconst next_node_value = stringify(value);\n\tif (hydrating && dom.nodeValue === next_node_value) {\n\t\t// In case of hydration don't reset the nodeValue as it's already correct.\n\t\t// @ts-expect-error need to add __nodeValue to patched prototype\n\t\tdom.__nodeValue = next_node_value;\n\t} else if (prev_node_value !== next_node_value) {\n\t\tdom.nodeValue = next_node_value;\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__nodeValue = next_node_value;\n\t}\n}\n\n/**\n * @param {Comment} anchor_node\n * @param {void | ((anchor: Comment, slot_props: Record<string, unknown>) => void)} slot_fn\n * @param {Record<string, unknown>} slot_props\n * @param {null | ((anchor: Comment) => void)} fallback_fn\n */\nexport function slot(anchor_node, slot_fn, slot_props, fallback_fn) {\n\thydrate_block_anchor(anchor_node);\n\tif (slot_fn === undefined) {\n\t\tif (fallback_fn !== null) {\n\t\t\tfallback_fn(anchor_node);\n\t\t}\n\t} else {\n\t\tslot_fn(anchor_node, slot_props);\n\t}\n}\n\n/**\n * @param {unknown} value\n * @returns {string}\n */\nexport function stringify(value) {\n\treturn typeof value === 'string' ? value : value == null ? '' : value + '';\n}\n\n// TODO 5.0 remove this\n/**\n * @deprecated Use `mount` or `hydrate` instead\n */\nexport function createRoot() {\n\tthrow new Error(\n\t\t'`createRoot` has been removed. Use `mount` or `hydrate` instead. See the updated docs for more info: https://svelte-5-preview.vercel.app/docs/breaking-changes#components-are-no-longer-classes'\n\t);\n}\n\n/**\n * Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @template {Record<string, any>} Events\n * @param {import('../../main/public.js').ComponentType<import('../../main/public.js').SvelteComponent<Props, Events>>} component\n * @param {{\n * \t\ttarget: Node;\n * \t\tprops?: Props;\n * \t\tevents?: { [Property in keyof Events]: (e: Events[Property]) => any };\n *  \tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t}} options\n * @returns {Exports}\n */\nexport function mount(component, options) {\n\tinit_operations();\n\tconst anchor = empty();\n\toptions.target.appendChild(anchor);\n\t// Don't flush previous effects to ensure order of outer effects stays consistent\n\treturn flush_sync(() => _mount(component, { ...options, anchor }), false);\n}\n\n/**\n * Hydrates a component on the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @template {Record<string, any>} Events\n * @param {import('../../main/public.js').ComponentType<import('../../main/public.js').SvelteComponent<Props, Events>>} component\n * @param {{\n * \t\ttarget: Node;\n * \t\tprops?: Props;\n * \t\tevents?: { [Property in keyof Events]: (e: Events[Property]) => any };\n *  \tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t\trecover?: false;\n * \t}} options\n * @returns {Exports}\n */\nexport function hydrate(component, options) {\n\tinit_operations();\n\tconst container = options.target;\n\tconst first_child = /** @type {ChildNode} */ (container.firstChild);\n\t// Call with insert_text == true to prevent empty {expressions} resulting in an empty\n\t// fragment array, resulting in a hydration error down the line\n\tconst hydration_fragment = get_hydration_fragment(first_child, true);\n\tconst previous_hydration_fragment = current_hydration_fragment;\n\tset_current_hydration_fragment(hydration_fragment);\n\n\t/** @type {null | Text} */\n\tlet anchor = null;\n\tif (hydration_fragment === null) {\n\t\tanchor = empty();\n\t\tcontainer.appendChild(anchor);\n\t}\n\n\tlet finished_hydrating = false;\n\n\ttry {\n\t\t// Don't flush previous effects to ensure order of outer effects stays consistent\n\t\treturn flush_sync(() => {\n\t\t\tconst instance = _mount(component, { ...options, anchor });\n\t\t\t// flush_sync will run this callback and then synchronously run any pending effects,\n\t\t\t// which don't belong to the hydration phase anymore - therefore reset it here\n\t\t\tset_current_hydration_fragment(null);\n\t\t\tfinished_hydrating = true;\n\t\t\treturn instance;\n\t\t}, false);\n\t} catch (error) {\n\t\tif (!finished_hydrating && options.recover !== false && hydration_fragment !== null) {\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.error(\n\t\t\t\t'ERR_SVELTE_HYDRATION_MISMATCH' +\n\t\t\t\t\t(DEV\n\t\t\t\t\t\t? ': Hydration failed because the initial UI does not match what was rendered on the server.'\n\t\t\t\t\t\t: ''),\n\t\t\t\terror\n\t\t\t);\n\t\t\tremove(hydration_fragment);\n\t\t\tfirst_child.remove();\n\t\t\thydration_fragment[hydration_fragment.length - 1]?.nextSibling?.remove();\n\t\t\tset_current_hydration_fragment(null);\n\t\t\treturn mount(component, options);\n\t\t} else {\n\t\t\tthrow error;\n\t\t}\n\t} finally {\n\t\tset_current_hydration_fragment(previous_hydration_fragment);\n\t}\n}\n\n/**\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @template {Record<string, any>} Events\n * @param {import('../../main/public.js').ComponentType<import('../../main/public.js').SvelteComponent<Props, Events>>} Component\n * @param {{\n * \t\ttarget: Node;\n * \t\tanchor: null | Text;\n * \t\tprops?: Props;\n * \t\tevents?: { [Property in keyof Events]: (e: Events[Property]) => any };\n *  \tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t\trecover?: false;\n * \t}} options\n * @returns {Exports}\n */\nfunction _mount(Component, options) {\n\tconst registered_events = new Set();\n\tconst container = options.target;\n\n\t/** @type {import('#client').RootBlock} */\n\tconst block = {\n\t\t// dom\n\t\td: null,\n\t\t// effect\n\t\te: null,\n\t\t// intro\n\t\ti: options.intro || false,\n\t\t// parent\n\t\tp: null,\n\t\t// transition\n\t\tr: null,\n\t\t// type\n\t\tt: ROOT_BLOCK\n\t};\n\n\t/** @type {Exports} */\n\t// @ts-expect-error will be defined because the render effect runs synchronously\n\tlet component = undefined;\n\n\tconst effect = render_effect(\n\t\t() => {\n\t\t\tif (options.context) {\n\t\t\t\tpush({});\n\t\t\t\t/** @type {import('../client/types.js').ComponentContext} */ (current_component_context).c =\n\t\t\t\t\toptions.context;\n\t\t\t}\n\t\t\tif (!options.props) {\n\t\t\t\toptions.props = /** @type {Props} */ ({});\n\t\t\t}\n\t\t\tif (options.events) {\n\t\t\t\t// We can't spread the object or else we'd lose the state proxy stuff, if it is one\n\t\t\t\t/** @type {any} */ (options.props).$$events = options.events;\n\t\t\t}\n\t\t\tcomponent =\n\t\t\t\t// @ts-expect-error the public typings are not what the actual function looks like\n\t\t\t\tComponent(options.anchor, options.props) || {};\n\t\t\tif (options.context) {\n\t\t\t\tpop();\n\t\t\t}\n\t\t},\n\t\tblock,\n\t\ttrue\n\t);\n\tblock.e = effect;\n\tconst bound_event_listener = handle_event_propagation.bind(null, container);\n\tconst bound_document_event_listener = handle_event_propagation.bind(null, document);\n\n\t/** @param {Array<string>} events */\n\tconst event_handle = (events) => {\n\t\tfor (let i = 0; i < events.length; i++) {\n\t\t\tconst event_name = events[i];\n\t\t\tif (!registered_events.has(event_name)) {\n\t\t\t\tregistered_events.add(event_name);\n\t\t\t\t// Add the event listener to both the container and the document.\n\t\t\t\t// The container listener ensures we catch events from within in case\n\t\t\t\t// the outer content stops propagation of the event.\n\t\t\t\tcontainer.addEventListener(\n\t\t\t\t\tevent_name,\n\t\t\t\t\tbound_event_listener,\n\t\t\t\t\tPassiveDelegatedEvents.includes(event_name)\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tpassive: true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: undefined\n\t\t\t\t);\n\t\t\t\t// The document listener ensures we catch events that originate from elements that were\n\t\t\t\t// manually moved outside of the container (e.g. via manual portals).\n\t\t\t\tdocument.addEventListener(\n\t\t\t\t\tevent_name,\n\t\t\t\t\tbound_document_event_listener,\n\t\t\t\t\tPassiveDelegatedEvents.includes(event_name)\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tpassive: true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: undefined\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t};\n\tevent_handle(array_from(all_registered_events));\n\troot_event_handles.add(event_handle);\n\n\tmounted_components.set(component, () => {\n\t\tfor (const event_name of registered_events) {\n\t\t\tcontainer.removeEventListener(event_name, bound_event_listener);\n\t\t}\n\t\troot_event_handles.delete(event_handle);\n\t\tconst dom = block.d;\n\t\tif (dom !== null) {\n\t\t\tremove(dom);\n\t\t}\n\t\tdestroy_effect(/** @type {import('./types.js').Effect} */ (block.e));\n\t});\n\n\treturn component;\n}\n\n/**\n * References of the components that were mounted or hydrated.\n * Uses a `WeakMap` to avoid memory leaks.\n */\nlet mounted_components = new WeakMap();\n\n/**\n * Unmounts a component that was previously mounted using `mount` or `hydrate`.\n * @param {Record<string, any>} component\n */\nexport function unmount(component) {\n\tconst fn = mounted_components.get(component);\n\tif (DEV && !fn) {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.warn('Tried to unmount a component that was not mounted.');\n\t}\n\tfn?.();\n}\n\n/**\n * @param {Record<string, any>} props\n * @returns {Record<string, any>}\n */\nexport function sanitize_slots(props) {\n\tconst sanitized = { ...props.$$slots };\n\tif (props.children) sanitized.default = props.children;\n\treturn sanitized;\n}\n\n/**\n * @param {Node} target\n * @param {string} style_sheet_id\n * @param {string} styles\n */\nexport async function append_styles(target, style_sheet_id, styles) {\n\t// Wait a tick so that the template is added to the dom, else getRootNode() will yield wrong results\n\t// If it turns out that this results in noticeable flickering, we need to do something like doing the\n\t// append outside and adding code in mount that appends all stylesheets (similar to how we do it with event delegation)\n\tawait Promise.resolve();\n\tconst append_styles_to = get_root_for_style(target);\n\tif (!append_styles_to.getElementById(style_sheet_id)) {\n\t\tconst style = create_element('style');\n\t\tstyle.id = style_sheet_id;\n\t\tstyle.textContent = styles;\n\t\tappend_child(/** @type {Document} */ (append_styles_to).head || append_styles_to, style);\n\t}\n}\n\n/**\n * @param {Node} node\n */\nfunction get_root_for_style(node) {\n\tif (!node) return document;\n\tconst root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n\tif (root && /** @type {ShadowRoot} */ (root).host) {\n\t\treturn /** @type {ShadowRoot} */ (root);\n\t}\n\treturn /** @type {Document} */ (node.ownerDocument);\n}\n","import { render_effect } from '../../reactivity/effects.js';\nimport { all_registered_events, root_event_handles } from '../../render.js';\nimport { define_property, is_array } from '../../utils.js';\n\n/**\n * @param {string} event_name\n * @param {Element} dom\n * @param {EventListener} handler\n * @param {boolean} capture\n * @param {boolean} [passive]\n * @returns {void}\n */\nexport function event(event_name, dom, handler, capture, passive) {\n\tvar options = { capture, passive };\n\n\t/**\n\t * @this {EventTarget}\n\t */\n\tfunction target_handler(/** @type {Event} */ event) {\n\t\thandle_event_propagation(dom, event);\n\t\tif (!event.cancelBubble) {\n\t\t\treturn handler.call(this, event);\n\t\t}\n\t}\n\n\tdom.addEventListener(event_name, target_handler, options);\n\n\t// @ts-ignore\n\tif (dom === document.body || dom === window || dom === document) {\n\t\trender_effect(() => {\n\t\t\treturn () => {\n\t\t\t\tdom.removeEventListener(event_name, target_handler, options);\n\t\t\t};\n\t\t});\n\t}\n}\n\n/**\n * @param {Array<string>} events\n * @returns {void}\n */\nexport function delegate(events) {\n\tfor (var i = 0; i < events.length; i++) {\n\t\tall_registered_events.add(events[i]);\n\t}\n\n\tfor (var fn of root_event_handles) {\n\t\tfn(events);\n\t}\n}\n\n/**\n * @param {Node} handler_element\n * @param {Event} event\n * @returns {void}\n */\nexport function handle_event_propagation(handler_element, event) {\n\tvar owner_document = handler_element.ownerDocument;\n\tvar event_name = event.type;\n\tvar path = event.composedPath?.() || [];\n\tvar current_target = /** @type {null | Element} */ (path[0] || event.target);\n\n\tif (event.target !== current_target) {\n\t\tdefine_property(event, 'target', {\n\t\t\tconfigurable: true,\n\t\t\tvalue: current_target\n\t\t});\n\t}\n\n\t// composedPath contains list of nodes the event has propagated through.\n\t// We check __root to skip all nodes below it in case this is a\n\t// parent of the __root node, which indicates that there's nested\n\t// mounted apps. In this case we don't want to trigger events multiple times.\n\tvar path_idx = 0;\n\n\t// @ts-expect-error is added below\n\tvar handled_at = event.__root;\n\n\tif (handled_at) {\n\t\tvar at_idx = path.indexOf(handled_at);\n\t\tif (\n\t\t\tat_idx !== -1 &&\n\t\t\t(handler_element === document || handler_element === /** @type {any} */ (window))\n\t\t) {\n\t\t\t// This is the fallback document listener or a window listener, but the event was already handled\n\t\t\t// -> ignore, but set handle_at to document/window so that we're resetting the event\n\t\t\t// chain in case someone manually dispatches the same event object again.\n\t\t\t// @ts-expect-error\n\t\t\tevent.__root = handler_element;\n\t\t\treturn;\n\t\t}\n\n\t\t// We're deliberately not skipping if the index is higher, because\n\t\t// someone could create an event programmatically and emit it multiple times,\n\t\t// in which case we want to handle the whole propagation chain properly each time.\n\t\t// (this will only be a false negative if the event is dispatched multiple times and\n\t\t// the fallback document listener isn't reached in between, but that's super rare)\n\t\tvar handler_idx = path.indexOf(handler_element);\n\t\tif (handler_idx === -1) {\n\t\t\t// handle_idx can theoretically be -1 (happened in some JSDOM testing scenarios with an event listener on the window object)\n\t\t\t// so guard against that, too, and assume that everything was handled at this point.\n\t\t\treturn;\n\t\t}\n\n\t\tif (at_idx <= handler_idx) {\n\t\t\t// +1 because at_idx is the element which was already handled, and there can only be one delegated event per element.\n\t\t\t// Avoids on:click and onclick on the same event resulting in onclick being fired twice.\n\t\t\tpath_idx = at_idx + 1;\n\t\t}\n\t}\n\n\tcurrent_target = /** @type {Element} */ (path[path_idx] || event.target);\n\n\t// Proxy currentTarget to correct target\n\tdefine_property(event, 'currentTarget', {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn current_target || owner_document;\n\t\t}\n\t});\n\n\twhile (current_target !== null) {\n\t\t/** @type {null | Element} */\n\t\tvar parent_element =\n\t\t\tcurrent_target.parentNode || /** @type {any} */ (current_target).host || null;\n\t\tvar internal_prop_name = '__' + event_name;\n\t\t// @ts-ignore\n\t\tvar delegated = current_target[internal_prop_name];\n\n\t\tif (delegated !== undefined && !(/** @type {any} */ (current_target).disabled)) {\n\t\t\tif (is_array(delegated)) {\n\t\t\t\tvar [fn, ...data] = delegated;\n\t\t\t\tfn.apply(current_target, [event, ...data]);\n\t\t\t} else {\n\t\t\t\tdelegated.call(current_target, event);\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\tevent.cancelBubble ||\n\t\t\tparent_element === handler_element ||\n\t\t\tcurrent_target === handler_element\n\t\t) {\n\t\t\tbreak;\n\t\t}\n\n\t\tcurrent_target = parent_element;\n\t}\n\n\t// @ts-expect-error is used above\n\tevent.__root = handler_element;\n\t// @ts-expect-error is used above\n\tcurrent_target = handler_element;\n}\n","import { DEV } from 'esm-env';\nimport { hydrating } from '../hydration.js';\nimport { render_effect } from '../../reactivity/effects.js';\nimport { get_descriptors, map_get, map_set, object_assign } from '../../utils.js';\nimport { AttributeAliases, DelegatedEvents, namespace_svg } from '../../../../constants.js';\nimport { delegate } from './events.js';\nimport { autofocus } from './misc.js';\n\n/**\n * The value/checked attribute in the template actually corresponds to the defaultValue property, so we need\n * to remove it upon hydration to avoid a bug when someone resets the form value.\n * @param {HTMLInputElement | HTMLSelectElement} dom\n * @returns {void}\n */\nexport function remove_input_attr_defaults(dom) {\n\tif (hydrating) {\n\t\tattr(dom, 'value', null);\n\t\tattr(dom, 'checked', null);\n\t}\n}\n\n/**\n * @param {Element} dom\n * @param {string} attribute\n * @param {() => string} value\n */\nexport function attr_effect(dom, attribute, value) {\n\trender_effect(() => {\n\t\tattr(dom, attribute, value());\n\t});\n}\n\n/**\n * @param {Element} dom\n * @param {string} attribute\n * @param {string | null} value\n */\nexport function attr(dom, attribute, value) {\n\tvalue = value == null ? null : value + '';\n\n\tif (DEV) {\n\t\tcheck_src_in_dev_hydration(dom, attribute, value);\n\t}\n\n\tif (\n\t\t!hydrating ||\n\t\t(dom.getAttribute(attribute) !== value &&\n\t\t\t// If we reset those, they would result in another network request, which we want to avoid.\n\t\t\t// We assume they are the same between client and server as checking if they are equal is expensive\n\t\t\t// (we can't just compare the strings as they can be different between client and server but result in the\n\t\t\t// same url, so we would need to create hidden anchor elements to compare them)\n\t\t\tattribute !== 'src' &&\n\t\t\tattribute !== 'href' &&\n\t\t\tattribute !== 'srcset')\n\t) {\n\t\tif (value === null) {\n\t\t\tdom.removeAttribute(attribute);\n\t\t} else {\n\t\t\tdom.setAttribute(attribute, value);\n\t\t}\n\t}\n}\n\n/**\n * @param {Element} dom\n * @param {string} attribute\n * @param {() => string} value\n */\nexport function xlink_attr_effect(dom, attribute, value) {\n\trender_effect(() => {\n\t\txlink_attr(dom, attribute, value());\n\t});\n}\n\n/**\n * @param {Element} dom\n * @param {string} attribute\n * @param {string} value\n */\nexport function xlink_attr(dom, attribute, value) {\n\tdom.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\n\n/**\n * @param {any} node\n * @param {string} prop\n * @param {() => any} value\n */\nexport function set_custom_element_data_effect(node, prop, value) {\n\trender_effect(() => {\n\t\tset_custom_element_data(node, prop, value());\n\t});\n}\n\n/**\n * @param {any} node\n * @param {string} prop\n * @param {any} value\n */\nexport function set_custom_element_data(node, prop, value) {\n\tif (prop in node) {\n\t\tnode[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n\t} else {\n\t\tattr(node, prop, value);\n\t}\n}\n\n/**\n * Like `spread_attributes` but self-contained\n * @param {Element & ElementCSSInlineStyle} dom\n * @param {() => Record<string, unknown>[]} attrs\n * @param {boolean} lowercase_attributes\n * @param {string} css_hash\n */\nexport function spread_attributes_effect(dom, attrs, lowercase_attributes, css_hash) {\n\t/** @type {Record<string, any> | undefined} */\n\tvar current;\n\n\trender_effect(() => {\n\t\tcurrent = spread_attributes(dom, current, attrs(), lowercase_attributes, css_hash);\n\t});\n}\n\n/**\n * Spreads attributes onto a DOM element, taking into account the currently set attributes\n * @param {Element & ElementCSSInlineStyle} dom\n * @param {Record<string, unknown> | undefined} prev\n * @param {Record<string, unknown>[]} attrs\n * @param {boolean} lowercase_attributes\n * @param {string} css_hash\n * @returns {Record<string, unknown>}\n */\nexport function spread_attributes(dom, prev, attrs, lowercase_attributes, css_hash) {\n\tvar next = object_assign({}, ...attrs);\n\tvar has_hash = css_hash.length !== 0;\n\n\tfor (var key in prev) {\n\t\tif (!(key in next)) {\n\t\t\tnext[key] = null;\n\t\t}\n\t}\n\n\tif (has_hash && !next.class) {\n\t\tnext.class = '';\n\t}\n\n\tvar setters = map_get(setters_cache, dom.nodeName);\n\tif (!setters) map_set(setters_cache, dom.nodeName, (setters = get_setters(dom)));\n\n\tfor (key in next) {\n\t\tvar value = next[key];\n\t\tif (value === prev?.[key]) continue;\n\n\t\tvar prefix = key[0] + key[1]; // this is faster than key.slice(0, 2)\n\t\tif (prefix === '$$') continue;\n\n\t\tif (prefix === 'on') {\n\t\t\t/** @type {{ capture?: true }} */\n\t\t\tvar opts = {};\n\t\t\tvar event_name = key.slice(2);\n\t\t\tvar delegated = DelegatedEvents.includes(event_name);\n\n\t\t\tif (\n\t\t\t\tevent_name.endsWith('capture') &&\n\t\t\t\tevent_name !== 'ongotpointercapture' &&\n\t\t\t\tevent_name !== 'onlostpointercapture'\n\t\t\t) {\n\t\t\t\tevent_name = event_name.slice(0, -7);\n\t\t\t\topts.capture = true;\n\t\t\t}\n\n\t\t\tif (!delegated && prev?.[key]) {\n\t\t\t\tdom.removeEventListener(event_name, /** @type {any} */ (prev[key]), opts);\n\t\t\t}\n\n\t\t\tif (value != null) {\n\t\t\t\tif (!delegated) {\n\t\t\t\t\tdom.addEventListener(event_name, value, opts);\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tdom[`__${event_name}`] = value;\n\t\t\t\t\tdelegate([event_name]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (value == null) {\n\t\t\tdom.removeAttribute(key);\n\t\t} else if (key === 'style') {\n\t\t\tdom.style.cssText = value + '';\n\t\t} else if (key === 'autofocus') {\n\t\t\tautofocus(/** @type {HTMLElement} */ (dom), Boolean(value));\n\t\t} else if (key === '__value' || key === 'value') {\n\t\t\t// @ts-ignore\n\t\t\tdom.value = dom[key] = dom.__value = value;\n\t\t} else {\n\t\t\tvar name = key;\n\t\t\tif (lowercase_attributes) {\n\t\t\t\tname = name.toLowerCase();\n\t\t\t\tname = AttributeAliases[name] || name;\n\t\t\t}\n\n\t\t\tif (setters.includes(name)) {\n\t\t\t\tif (DEV) {\n\t\t\t\t\tcheck_src_in_dev_hydration(dom, name, value);\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\t!hydrating ||\n\t\t\t\t\t//  @ts-ignore see attr method for an explanation of src/srcset\n\t\t\t\t\t(dom[name] !== value && name !== 'src' && name !== 'href' && name !== 'srcset')\n\t\t\t\t) {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tdom[name] = value;\n\t\t\t\t}\n\t\t\t} else if (typeof value !== 'function') {\n\t\t\t\tif (has_hash && name === 'class') {\n\t\t\t\t\tif (value) value += ' ';\n\t\t\t\t\tvalue += css_hash;\n\t\t\t\t}\n\n\t\t\t\tattr(dom, name, value);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn next;\n}\n\n/**\n * @param {Element} node\n * @param {() => Record<string, unknown>[]} attrs\n * @param {string} css_hash\n */\nexport function spread_dynamic_element_attributes_effect(node, attrs, css_hash) {\n\t/** @type {Record<string, any> | undefined} */\n\tvar current;\n\n\trender_effect(() => {\n\t\tcurrent = spread_dynamic_element_attributes(node, current, attrs(), css_hash);\n\t});\n}\n\n/**\n * @param {Element} node\n * @param {Record<string, unknown> | undefined} prev\n * @param {Record<string, unknown>[]} attrs\n * @param {string} css_hash\n */\nexport function spread_dynamic_element_attributes(node, prev, attrs, css_hash) {\n\tif (node.tagName.includes('-')) {\n\t\tvar next = object_assign({}, ...attrs);\n\n\t\tfor (var key in prev) {\n\t\t\tif (!(key in next)) {\n\t\t\t\tnext[key] = null;\n\t\t\t}\n\t\t}\n\n\t\tfor (key in next) {\n\t\t\tset_custom_element_data(node, key, next[key]);\n\t\t}\n\n\t\treturn next;\n\t} else {\n\t\treturn spread_attributes(\n\t\t\t/** @type {Element & ElementCSSInlineStyle} */ (node),\n\t\t\tprev,\n\t\t\tattrs,\n\t\t\tnode.namespaceURI !== namespace_svg,\n\t\t\tcss_hash\n\t\t);\n\t}\n}\n\n/**\n * List of attributes that should always be set through the attr method,\n * because updating them through the property setter doesn't work reliably.\n * In the example of `width`/`height`, the problem is that the setter only\n * accepts numeric values, but the attribute can also be set to a string like `50%`.\n * If this list becomes too big, rethink this approach.\n */\nvar always_set_through_set_attribute = ['width', 'height'];\n\n/** @type {Map<string, string[]>} */\nvar setters_cache = new Map();\n\n/** @param {Element} element */\nfunction get_setters(element) {\n\t/** @type {string[]} */\n\tvar setters = [];\n\n\t// @ts-expect-error\n\tvar descriptors = get_descriptors(element.__proto__);\n\n\tfor (var key in descriptors) {\n\t\tif (descriptors[key].set && !always_set_through_set_attribute.includes(key)) {\n\t\t\tsetters.push(key);\n\t\t}\n\t}\n\n\treturn setters;\n}\n\n/**\n * @param {any} dom\n * @param {string} attribute\n * @param {string | null} value\n */\nfunction check_src_in_dev_hydration(dom, attribute, value) {\n\tif (!hydrating) return;\n\tif (attribute !== 'src' && attribute !== 'href' && attribute !== 'srcset') return;\n\n\tif (attribute === 'srcset' && srcset_url_equal(dom, value)) return;\n\tif (src_url_equal(dom.getAttribute(attribute) ?? '', value ?? '')) return;\n\n\t// eslint-disable-next-line no-console\n\tconsole.error(\n\t\t`Detected a ${attribute} attribute value change during hydration. This will not be repaired during hydration, ` +\n\t\t\t`the ${attribute} value that came from the server will be used. Related element:`,\n\t\tdom,\n\t\t' Differing value:',\n\t\tvalue\n\t);\n}\n\n/**\n * @param {string} element_src\n * @param {string} url\n * @returns {boolean}\n */\nfunction src_url_equal(element_src, url) {\n\tif (element_src === url) return true;\n\treturn new URL(element_src, document.baseURI).href === new URL(url, document.baseURI).href;\n}\n\n/** @param {string} srcset */\nfunction split_srcset(srcset) {\n\treturn srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));\n}\n\n/**\n * @param {HTMLSourceElement | HTMLImageElement} element\n * @param {string | undefined | null} srcset\n * @returns {boolean}\n */\nexport function srcset_url_equal(element, srcset) {\n\tvar element_urls = split_srcset(element.srcset);\n\tvar urls = split_srcset(srcset ?? '');\n\n\treturn (\n\t\turls.length === element_urls.length &&\n\t\turls.every(\n\t\t\t([url, width], i) =>\n\t\t\t\twidth === element_urls[i][1] &&\n\t\t\t\t// We need to test both ways because Vite will create an a full URL with\n\t\t\t\t// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the\n\t\t\t\t// relative URLs inside srcset are not automatically resolved to absolute URLs by\n\t\t\t\t// browsers (in contrast to img.src). This means both SSR and DOM code could\n\t\t\t\t// contain relative or absolute URLs.\n\t\t\t\t(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))\n\t\t)\n\t);\n}\n","import { run } from '../../../common.js';\nimport { pre_effect, user_effect } from '../../reactivity/effects.js';\nimport {\n\tcurrent_component_context,\n\tdeep_read_state,\n\tflush_local_render_effects,\n\tget,\n\tuntrack\n} from '../../runtime.js';\n\n/**\n * Legacy-mode only: Call `onMount` callbacks and set up `beforeUpdate`/`afterUpdate` effects\n */\nexport function init() {\n\tconst context = /** @type {import('#client').ComponentContext} */ (current_component_context);\n\tconst callbacks = context.u;\n\n\tif (!callbacks) return;\n\n\t// beforeUpdate\n\tif (callbacks.b.length) {\n\t\tpre_effect(() => {\n\t\t\tobserve_all(context);\n\t\t\tcallbacks.b.forEach(run);\n\t\t\t// beforeUpdate might change state that affects rendering, ensure the render effects following from it\n\t\t\t// are batched up with the current run. Avoids for example child components rerunning when they're\n\t\t\t// now hidden because beforeUpdate did set an if block to false.\n\t\t\tflush_local_render_effects();\n\t\t});\n\t}\n\n\t// onMount (must run before afterUpdate)\n\tuser_effect(() => {\n\t\tconst fns = untrack(() => callbacks.m.map(run));\n\t\treturn () => {\n\t\t\tfor (const fn of fns) {\n\t\t\t\tif (typeof fn === 'function') {\n\t\t\t\t\tfn();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n\n\t// afterUpdate\n\tif (callbacks.a.length) {\n\t\tuser_effect(() => {\n\t\t\tobserve_all(context);\n\t\t\tcallbacks.a.forEach(run);\n\t\t});\n\t}\n}\n\n/**\n * Invoke the getter of all signals associated with a component\n * so they can be registered to the effect this function is called in.\n * @param {import('#client').ComponentContext} context\n */\nfunction observe_all(context) {\n\tif (context.d) {\n\t\tfor (const signal of context.d) get(signal);\n\t}\n\n\tdeep_read_state(context.s);\n}\n","import { set, source } from '../../reactivity/sources.js';\nimport { get } from '../../runtime.js';\nimport { is_array } from '../../utils.js';\n\n/**\n * Under some circumstances, imports may be reactive in legacy mode. In that case,\n * they should be using `reactive_import` as part of the transformation\n * @param {() => any} fn\n */\nexport function reactive_import(fn) {\n\tvar s = source(0);\n\n\treturn function () {\n\t\tif (arguments.length === 1) {\n\t\t\tset(s, get(s) + 1);\n\t\t\treturn arguments[0];\n\t\t} else {\n\t\t\tget(s);\n\t\t\treturn fn();\n\t\t}\n\t};\n}\n\n/**\n * @this {any}\n * @param {Record<string, unknown>} $$props\n * @param {Event} event\n * @returns {void}\n */\nexport function bubble_event($$props, event) {\n\tvar events = /** @type {Record<string, Function[] | Function>} */ ($$props.$$events)?.[\n\t\tevent.type\n\t];\n\n\tvar callbacks = is_array(events) ? events.slice() : events == null ? [] : [events];\n\n\tfor (var fn of callbacks) {\n\t\t// Preserve \"this\" context\n\t\tfn.call(this, event);\n\t}\n}\n\n/**\n * Used to simulate `$on` on a component instance when `legacy.componentApi` is `true`\n * @param {Record<string, any>} $$props\n * @param {string} event_name\n * @param {Function} event_callback\n */\nexport function add_legacy_event_listener($$props, event_name, event_callback) {\n\t$$props.$$events ||= {};\n\t$$props.$$events[event_name] ||= [];\n\t$$props.$$events[event_name].push(event_callback);\n}\n\n/**\n * Used to simulate `$set` on a component instance when `legacy.componentApi` is `true`.\n * Needs component accessors so that it can call the setter of the prop. Therefore doesn't\n * work for updating props in `$$props` or `$$restProps`.\n * @this {Record<string, any>}\n * @param {Record<string, any>} $$new_props\n */\nexport function update_legacy_props($$new_props) {\n\tfor (var key in $$new_props) {\n\t\tif (key in this) {\n\t\t\tthis[key] = $$new_props[key];\n\t\t}\n\t}\n}\n","import { current_hydration_fragment, hydrate_block_anchor, hydrating } from './hydration.js';\nimport { child, clone_node, empty } from './operations.js';\nimport {\n\tcreate_fragment_from_html,\n\tcreate_fragment_with_script_from_html,\n\tinsert\n} from './reconciler.js';\nimport { current_block } from '../runtime.js';\nimport { is_array } from '../utils.js';\n\n/**\n * @param {string} html\n * @param {boolean} return_fragment\n * @returns {() => Node}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function template(html, return_fragment) {\n\t/** @type {undefined | Node} */\n\tlet cached_content;\n\treturn () => {\n\t\tif (cached_content === undefined) {\n\t\t\tconst content = create_fragment_from_html(html);\n\t\t\tcached_content = return_fragment ? content : /** @type {Node} */ (child(content));\n\t\t}\n\t\treturn cached_content;\n\t};\n}\n\n/**\n * @param {string} html\n * @param {boolean} return_fragment\n * @returns {() => Node}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function template_with_script(html, return_fragment) {\n\t/** @type {undefined | Node} */\n\tlet cached_content;\n\treturn () => {\n\t\tif (cached_content === undefined) {\n\t\t\tconst content = create_fragment_with_script_from_html(html);\n\t\t\tcached_content = return_fragment ? content : /** @type {Node} */ (child(content));\n\t\t}\n\t\treturn cached_content;\n\t};\n}\n\n/**\n * @param {string} svg\n * @param {boolean} return_fragment\n * @returns {() => Node}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function svg_template(svg, return_fragment) {\n\t/** @type {undefined | Node} */\n\tlet cached_content;\n\treturn () => {\n\t\tif (cached_content === undefined) {\n\t\t\tconst content = /** @type {Node} */ (child(create_fragment_from_html(`<svg>${svg}</svg>`)));\n\t\t\tcached_content = return_fragment ? content : /** @type {Node} */ (child(content));\n\t\t}\n\t\treturn cached_content;\n\t};\n}\n\n/**\n * @param {string} svg\n * @param {boolean} return_fragment\n * @returns {() => Node}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function svg_template_with_script(svg, return_fragment) {\n\t/** @type {undefined | Node} */\n\tlet cached_content;\n\treturn () => {\n\t\tif (cached_content === undefined) {\n\t\t\tconst content = /** @type {Node} */ (child(create_fragment_from_html(`<svg>${svg}</svg>`)));\n\t\t\tcached_content = return_fragment ? content : /** @type {Node} */ (child(content));\n\t\t}\n\t\treturn cached_content;\n\t};\n}\n\n/**\n * @param {boolean} is_fragment\n * @param {boolean} use_clone_node\n * @param {null | Text | Comment | Element} anchor\n * @param {() => Node} [template_element_fn]\n * @returns {Element | DocumentFragment | Node[]}\n */\nfunction open_template(is_fragment, use_clone_node, anchor, template_element_fn) {\n\tif (hydrating) {\n\t\tif (anchor !== null) {\n\t\t\thydrate_block_anchor(anchor, false);\n\t\t}\n\t\t// In ssr+hydration optimization mode, we might remove the template_element,\n\t\t// so we need to is_fragment flag to properly handle hydrated content accordingly.\n\t\tconst fragment = current_hydration_fragment;\n\t\tif (fragment !== null) {\n\t\t\treturn is_fragment ? fragment : /** @type {Element} */ (fragment[0]);\n\t\t}\n\t}\n\treturn use_clone_node\n\t\t? clone_node(/** @type {() => Element} */ (template_element_fn)(), true)\n\t\t: document.importNode(/** @type {() => Element} */ (template_element_fn)(), true);\n}\n\n/**\n * @param {null | Text | Comment | Element} anchor\n * @param {boolean} use_clone_node\n * @param {() => Node} [template_element_fn]\n * @returns {Element | DocumentFragment | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function open(anchor, use_clone_node, template_element_fn) {\n\treturn open_template(false, use_clone_node, anchor, template_element_fn);\n}\n\n/**\n * @param {null | Text | Comment | Element} anchor\n * @param {boolean} use_clone_node\n * @param {() => Node} [template_element_fn]\n * @returns {Element | DocumentFragment | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function open_frag(anchor, use_clone_node, template_element_fn) {\n\treturn open_template(true, use_clone_node, anchor, template_element_fn);\n}\n\nconst space_template = template(' ', false);\nconst comment_template = template('<!>', true);\n\n/**\n * @param {Text | Comment | Element | null} anchor\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function space_frag(anchor) {\n\t/** @type {Node | null} */\n\tvar node = /** @type {any} */ (open(anchor, true, space_template));\n\t// if an {expression} is empty during SSR, there might be no\n\t// text node to hydrate (or an anchor comment is falsely detected instead)\n\t//  â€” we must therefore create one\n\tif (hydrating && node?.nodeType !== 3) {\n\t\tnode = empty();\n\t\t// @ts-ignore in this case the anchor should always be a comment,\n\t\t// if not something more fundamental is wrong and throwing here is better to bail out early\n\t\tanchor.before(node);\n\t}\n\treturn node;\n}\n\n/**\n * @param {Text | Comment | Element} anchor\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function space(anchor) {\n\t// if an {expression} is empty during SSR, there might be no\n\t// text node to hydrate (or an anchor comment is falsely detected instead)\n\t//  â€” we must therefore create one\n\tif (hydrating && anchor.nodeType !== 3) {\n\t\tconst node = empty();\n\t\tanchor.before(node);\n\t\treturn node;\n\t}\n\treturn anchor;\n}\n\n/**\n * @param {null | Text | Comment | Element} anchor\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function comment(anchor) {\n\treturn open_frag(anchor, true, comment_template);\n}\n\n/**\n * Assign the created (or in hydration mode, traversed) dom elements to the current block\n * and insert the elements into the dom (in client mode).\n * @param {Element | Text} dom\n * @param {boolean} is_fragment\n * @param {null | Text | Comment | Element} anchor\n * @returns {void}\n */\nfunction close_template(dom, is_fragment, anchor) {\n\tconst block = /** @type {import('#client').Block} */ (current_block);\n\n\t/** @type {import('#client').TemplateNode | Array<import('#client').TemplateNode>} */\n\tconst current = is_fragment\n\t\t? is_array(dom)\n\t\t\t? dom\n\t\t\t: /** @type {import('#client').TemplateNode[]} */ (Array.from(dom.childNodes))\n\t\t: dom;\n\tif (!hydrating && anchor !== null) {\n\t\tinsert(current, null, anchor);\n\t}\n\tblock.d = current;\n}\n\n/**\n * @param {null | Text | Comment | Element} anchor\n * @param {Element | Text} dom\n * @returns {void}\n */\nexport function close(anchor, dom) {\n\tclose_template(dom, false, anchor);\n}\n\n/**\n * @param {null | Text | Comment | Element} anchor\n * @param {Element | Text} dom\n * @returns {void}\n */\nexport function close_frag(anchor, dom) {\n\tclose_template(dom, true, anchor);\n}\n","import { DEV } from 'esm-env';\nimport {\n\tPROPS_IS_IMMUTABLE,\n\tPROPS_IS_LAZY_INITIAL,\n\tPROPS_IS_RUNES,\n\tPROPS_IS_UPDATED\n} from '../../../constants.js';\nimport { get_descriptor, is_function } from '../utils.js';\nimport { mutable_source, set } from './sources.js';\nimport { derived } from './deriveds.js';\nimport { get, inspect_fn, is_signals_recorded } from '../runtime.js';\nimport { safe_equals, safe_not_equal } from './equality.js';\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_prop(fn, d = 1) {\n\tconst value = fn();\n\tfn(value + d);\n\treturn value;\n}\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_prop(fn, d = 1) {\n\tconst value = fn() + d;\n\tfn(value);\n\treturn value;\n}\n\n/**\n * The proxy handler for rest props (i.e. `const { x, ...rest } = $props()`).\n * Is passed the full `$$props` object and excludes the named props.\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol> }>}}\n */\nconst rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\treturn target.props[key];\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} rest\n * @returns {Record<string, unknown>}\n */\nexport function rest_props(props, rest) {\n\treturn new Proxy({ props, exclude: rest }, rest_props_handler);\n}\n\n/**\n * The proxy handler for spread props. Handles the incoming array of props\n * that looks like `() => { dynamic: props }, { static: prop }, ..` and wraps\n * them so that the whole thing is passed to the component as the `$$props` argument.\n * @template {Record<string | symbol, unknown>} T\n * @type {ProxyHandler<{ props: Array<T | (() => T)> }>}}\n */\nconst spread_props_handler = {\n\tget(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) return p[key];\n\t\t}\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) return get_descriptor(p, key);\n\t\t}\n\t},\n\thas(target, key) {\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (key in p) return true;\n\t\t}\n\n\t\treturn false;\n\t},\n\townKeys(target) {\n\t\t/** @type {Array<string | symbol>} */\n\t\tconst keys = [];\n\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tfor (const key in p) {\n\t\t\t\tif (!keys.includes(key)) keys.push(key);\n\t\t\t}\n\t\t}\n\n\t\treturn keys;\n\t}\n};\n\n/**\n * @param {Array<Record<string, unknown> | (() => Record<string, unknown>)>} props\n * @returns {any}\n */\nexport function spread_props(...props) {\n\treturn new Proxy({ props }, spread_props_handler);\n}\n\n/**\n * This function is responsible for synchronizing a possibly bound prop with the inner component state.\n * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value.\n * @template V\n * @param {Record<string, unknown>} props\n * @param {string} key\n * @param {number} flags\n * @param {V | (() => V)} [initial]\n * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))}\n */\nexport function prop(props, key, flags, initial) {\n\tvar immutable = (flags & PROPS_IS_IMMUTABLE) !== 0;\n\tvar runes = (flags & PROPS_IS_RUNES) !== 0;\n\tvar prop_value = /** @type {V} */ (props[key]);\n\tvar setter = get_descriptor(props, key)?.set;\n\n\tif (prop_value === undefined && initial !== undefined) {\n\t\tif (setter && runes) {\n\t\t\t// TODO consolidate all these random runtime errors\n\t\t\tthrow new Error(\n\t\t\t\t'ERR_SVELTE_BINDING_FALLBACK' +\n\t\t\t\t\t(DEV\n\t\t\t\t\t\t? `: Cannot pass undefined to bind:${key} because the property contains a fallback value. Pass a different value than undefined to ${key}.`\n\t\t\t\t\t\t: '')\n\t\t\t);\n\t\t}\n\n\t\t// @ts-expect-error would need a cumbersome method overload to type this\n\t\tif ((flags & PROPS_IS_LAZY_INITIAL) !== 0) initial = initial();\n\n\t\tprop_value = /** @type {V} */ (initial);\n\n\t\tif (setter) setter(prop_value);\n\t}\n\n\tvar getter = () => {\n\t\tvar value = /** @type {V} */ (props[key]);\n\t\tif (value !== undefined) initial = undefined;\n\t\treturn value === undefined ? /** @type {V} */ (initial) : value;\n\t};\n\n\t// easy mode â€” prop is never written to\n\tif ((flags & PROPS_IS_UPDATED) === 0) {\n\t\treturn getter;\n\t}\n\n\t// intermediate mode â€” prop is written to, but the parent component had\n\t// `bind:foo` which means we can just call `$$props.foo = value` directly\n\tif (setter) {\n\t\treturn function (/** @type {V} */ value) {\n\t\t\tif (arguments.length === 1) {\n\t\t\t\t/** @type {Function} */ (setter)(value);\n\t\t\t\treturn value;\n\t\t\t} else {\n\t\t\t\treturn getter();\n\t\t\t}\n\t\t};\n\t}\n\n\t// hard mode. this is where it gets ugly â€” the value in the child should\n\t// synchronize with the parent, but it should also be possible to temporarily\n\t// set the value to something else locally.\n\tvar from_child = false;\n\tvar was_from_child = false;\n\n\t// The derived returns the current value. The underlying mutable\n\t// source is written to from various places to persist this value.\n\tvar inner_current_value = mutable_source(prop_value);\n\tvar current_value = derived(() => {\n\t\tvar parent_value = getter();\n\t\tvar child_value = get(inner_current_value);\n\n\t\tif (from_child) {\n\t\t\tfrom_child = false;\n\t\t\twas_from_child = true;\n\t\t\treturn child_value;\n\t\t}\n\n\t\twas_from_child = false;\n\t\treturn (inner_current_value.v = parent_value);\n\t});\n\n\tif (!immutable) current_value.equals = safe_equals;\n\n\treturn function (/** @type {V} */ value) {\n\t\tvar current = get(current_value);\n\n\t\t// legacy nonsense â€” need to ensure the source is invalidated when necessary\n\t\t// also needed for when handling inspect logic so we can inspect the correct source signal\n\t\tif (is_signals_recorded || (DEV && inspect_fn)) {\n\t\t\t// set this so that we don't reset to the parent value if `d`\n\t\t\t// is invalidated because of `invalidate_inner_signals` (rather\n\t\t\t// than because the parent or child value changed)\n\t\t\tfrom_child = was_from_child;\n\t\t\t// invoke getters so that signals are picked up by `invalidate_inner_signals`\n\t\t\tgetter();\n\t\t\tget(inner_current_value);\n\t\t}\n\n\t\tif (arguments.length > 0) {\n\t\t\tif (!current_value.equals(value)) {\n\t\t\t\tfrom_child = true;\n\t\t\t\tset(inner_current_value, value);\n\t\t\t\tget(current_value); // force a synchronisation immediately\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\n\t\treturn current;\n\t};\n}\n","import { current_component_context, untrack } from '../internal/client/runtime.js';\nimport { is_array } from '../internal/client/utils.js';\nimport { user_effect } from '../internal/index.js';\n\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.\n *\n * `onMount` does not run inside a [server-side component](https://svelte.dev/docs#run-time-server-side-component-api).\n *\n * https://svelte.dev/docs/svelte#onmount\n * @template T\n * @param {() => import('./private.js').NotFunction<T> | Promise<import('./private.js').NotFunction<T>> | (() => any)} fn\n * @returns {void}\n */\nexport function onMount(fn) {\n\tif (current_component_context === null) {\n\t\tthrow new Error('onMount can only be used during component initialisation.');\n\t}\n\n\tif (current_component_context.r) {\n\t\tuser_effect(() => {\n\t\t\tconst cleanup = untrack(fn);\n\t\t\tif (typeof cleanup === 'function') return /** @type {() => void} */ (cleanup);\n\t\t});\n\t} else {\n\t\tinit_update_callbacks(current_component_context).m.push(fn);\n\t}\n}\n\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * https://svelte.dev/docs/svelte#ondestroy\n * @param {() => any} fn\n * @returns {void}\n */\nexport function onDestroy(fn) {\n\tif (current_component_context === null) {\n\t\tthrow new Error('onDestroy can only be used during component initialisation.');\n\t}\n\n\tonMount(() => () => untrack(fn));\n}\n\n/**\n * @template [T=any]\n * @param {string} type\n * @param {T} [detail]\n * @param {any}params_0\n * @returns {CustomEvent<T>}\n */\nfunction create_custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n\treturn new CustomEvent(type, { detail, bubbles, cancelable });\n}\n\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](https://svelte.dev/docs#template-syntax-component-directives-on-eventname).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:\n * ```ts\n * const dispatch = createEventDispatcher<{\n *  loaded: never; // does not take a detail argument\n *  change: string; // takes a detail argument of type string, which is required\n *  optional: number | null; // takes an optional detail argument of type number\n * }>();\n * ```\n *\n * https://svelte.dev/docs/svelte#createeventdispatcher\n * @template {Record<string, any>} [EventMap = any]\n * @returns {import('./public.js').EventDispatcher<EventMap>}\n */\nexport function createEventDispatcher() {\n\tconst component_context = current_component_context;\n\tif (component_context === null) {\n\t\tthrow new Error('createEventDispatcher can only be used during component initialisation.');\n\t}\n\n\treturn (type, detail, options) => {\n\t\tconst events = /** @type {Record<string, Function | Function[]>} */ (\n\t\t\tcomponent_context.s.$$events\n\t\t)?.[/** @type {any} */ (type)];\n\n\t\tif (events) {\n\t\t\tconst callbacks = is_array(events) ? events.slice() : [events];\n\t\t\t// TODO are there situations where events could be dispatched\n\t\t\t// in a server (non-DOM) environment?\n\t\t\tconst event = create_custom_event(/** @type {string} */ (type), detail, options);\n\t\t\tfor (const fn of callbacks) {\n\t\t\t\tfn.call(component_context.x, event);\n\t\t\t}\n\t\t\treturn !event.defaultPrevented;\n\t\t}\n\n\t\treturn true;\n\t};\n}\n\n// TODO mark beforeUpdate and afterUpdate as deprecated in Svelte 6\n\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`.\n *\n * In runes mode use `$effect.pre` instead.\n *\n * https://svelte.dev/docs/svelte#beforeupdate\n * @deprecated Use `$effect.pre` instead â€” see https://svelte-5-preview.vercel.app/docs/deprecations#beforeupdate-and-afterupdate\n * @param {() => void} fn\n * @returns {void}\n */\nexport function beforeUpdate(fn) {\n\tif (current_component_context === null) {\n\t\tthrow new Error('beforeUpdate can only be used during component initialisation');\n\t}\n\n\tif (current_component_context.r) {\n\t\tthrow new Error('beforeUpdate cannot be used in runes mode');\n\t}\n\n\tinit_update_callbacks(current_component_context).b.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`.\n *\n * In runes mode use `$effect` instead.\n *\n * https://svelte.dev/docs/svelte#afterupdate\n * @deprecated Use `$effect` instead â€” see https://svelte-5-preview.vercel.app/docs/deprecations#beforeupdate-and-afterupdate\n * @param {() => void} fn\n * @returns {void}\n */\nexport function afterUpdate(fn) {\n\tif (current_component_context === null) {\n\t\tthrow new Error('afterUpdate can only be used during component initialisation.');\n\t}\n\n\tif (current_component_context.r) {\n\t\tthrow new Error('afterUpdate cannot be used in runes mode');\n\t}\n\n\tinit_update_callbacks(current_component_context).a.push(fn);\n}\n\n/**\n * Legacy-mode: Init callbacks object for onMount/beforeUpdate/afterUpdate\n * @param {import('../internal/client/types.js').ComponentContext} context\n */\nfunction init_update_callbacks(context) {\n\treturn (context.u ??= { a: [], b: [], m: [] });\n}\n\n// TODO bring implementations in here\n// (except probably untrack â€” do we want to expose that, if there's also a rune?)\nexport {\n\tflushSync,\n\tmount,\n\thydrate,\n\ttick,\n\tunmount,\n\tuntrack,\n\tunstate,\n\tcreateRoot,\n\thasContext,\n\tgetContext,\n\tgetAllContexts,\n\tsetContext\n} from '../internal/index.js';\n","import {\n  // dom/blocks/*\n  await as await_block, each_keyed, each_indexed, if as if_block, html,\n  // dom/elements/*\n  attr_effect, attr, event,\n  // dom/legacy/*\n  bubble_event, init,\n  // dom/operations.js\n  child, child_frag, sibling,\n  // dom/template.js\n  template, open, open_frag, space, comment, close, close_frag,\n  // reactivity/effects.js\n  legacy_pre_effect, legacy_pre_effect_reset, render_effect,\n  // reactivity/props.js\n  spread_props, prop,\n  // reactivity/sources.js\n  mutable_source, mutate, set,\n  // render.js\n  text_effect, text, mount, unmount, append_styles,\n  // runtime.js\n  get, push, pop,\n} from 'svelte/internal';\n\nimport {\n  createEventDispatcher,\n} from 'svelte';\n\nconst forward_event = (event_name, props) => {\n  return {\n    [event_name]: function (event) {\n      bubble_event.call(this, props, event);\n    },\n  };\n};\n\nconst forward_events = (events, props) => {\n  const object = {};\n\n  for (const event_name of events) {\n    object[event_name] = function (event) {\n      bubble_event.call(this, props, event);\n    };\n  }\n\n  return object;\n};\n\nconst event_bubble = (event_name, dom, props) => {\n  event(event_name, dom, function (event) {\n    bubble_event.call(this, props, event);\n  });\n};\n\nconst set_getter = (object, key, getter) => {\n  Object.defineProperty(object, key, {\n    get: getter,\n    enumerable: true,\n    configurable: true,\n  });\n};\n\nexport default {\n  await_block, each_keyed, each_indexed, if_block, html,\n  attr_effect, attr, event,\n  /* bubble_event, */ forward_event, forward_events, event_bubble, init,\n  child, child_frag, sibling,\n  template, open, open_frag, space, comment, close, close_frag,\n  legacy_pre_effect, legacy_pre_effect_reset, render_effect,\n  spread_props, prop,\n  mutable_source, mutate, set,\n  text_effect, text, mount, unmount, append_styles,\n  get, push, set_getter, pop,\n\n  createEventDispatcher,\n};\n"],"names":["source","init","derived","prop","get","child","html","sibling","block","flags","anchor_node","each","render","consequent_effect","result","alternate_effect","event"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]}